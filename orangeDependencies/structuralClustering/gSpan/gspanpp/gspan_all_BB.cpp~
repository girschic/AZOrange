/*
 * Portions Copyright (C) 2011 Simon A. Berger
 * 
 *  This program is free software; you may redistribute it and/or modify its
 *  under the terms of the GNU General Public License as published by the Free
 *  Software Foundation; either version 2 of the License, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful, but
 *  WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 *  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 *  for more details.
 */
#ifndef __GSPANXX_ALL_H
#define __GSPANXX_ALL_H

#define ETP edgeTupelPointer
#define ELEP edgeListElementPointer



// MAXFRAGSIZE
//#define AUSGABE
#define SPACESAVER
//#define SAVE_EMBEDDINGS
//#define DEBUG
//#define CLOCK
//#define SYMMETRY
//#define OCC_COUNT /* funktioniert nur, wenn in genPotCh nicht vorzeitig abgebrochen wird, wenn bereits alle fw2 ext gefunden wurden */

#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <algorithm>
#include <stdexcept>

// #include <boost/unordered_set.hpp>
// #include <boost/unordered_map.hpp>
#include <vector>
#include <exception>
#include <cassert>
#include <iostream>
#include <fstream>
#include <sstream>
#include "gSpan.h"
#include "ivymike/sdf.h"




struct blub {
    bool operator()(int i, int j) {
        return i < j;
    }
    
};

template<class T>
class histogram {
    std::vector<int> m_cts;
    T m_max;
    bool m_active;
    
public:
    histogram(int nbuckets, T max) : m_cts(nbuckets), m_max(max), m_active(false) 
    {}
    
    ~histogram() {
            
        if( m_active ) {
            print();
        }
        
    }
    void inc( T v ) {
        m_active = true;
        size_t b = float(v / m_max) * m_cts.size();
        b = std::max(size_t(0),std::min(m_cts.size()-1,b));
        m_cts.at(b)++;
        
    }
    
    void print() {
        for( size_t i = 0; i < m_cts.size(); i++ ) {
            T xmin = i * (m_max / m_cts.size());
            T xmax = (i+1) * (m_max / m_cts.size());
            
            
            std::cout << xmin << "-" << xmax << ":" << m_cts[i] << "\n";     
            
            
        }
        
    }
    
};

#include <tr1/unordered_set>

class gc_allocator {
    size_t nmalloc;// = 0;
    size_t ngcmalloc;// = 0;

    size_t nfree;// = 0;
    size_t nfreeub;// = 0;
    size_t ngcfree;// = 0;
    size_t maxnc;// = 0;

    
    std::tr1::unordered_set<void*> gc_set;
#if 1
    
    histogram<size_t> m_mhist;
//     boost::unordered_map<size_t,size_t>m_msizes;
    inline void mstat( size_t s ) {
//         m_mhist.inc(s);
        
//         m_msizes[s]++;
    }
    
public:
    gc_allocator() 
        : nmalloc(0),
        ngcmalloc(0),

        nfree(0),
        nfreeub(0),
        ngcfree(0),
        maxnc(0),
        m_mhist( 50, 100 ) 
    {}
        
        
    ~gc_allocator() {
        const bool verbose = false;
        
        if( verbose ) {
            printf("I am the destructor %zd %zd.\n", nmalloc, nfree);

            printf( "%zd ptrs in gc set\n", gc_set.size() );
        }
        size_t ncollect = 0;
        for ( std::tr1::unordered_set<void*>::iterator it = gc_set.begin(); it != gc_set.end(); ++it ) {
            std::free( *it );
            ncollect++;
        }


        if( verbose ) { 
            printf( "malloced: %zd %zd, freed %zd %zd (%zd) collected: %zd\n", nmalloc, ngcmalloc, nfree, ngcfree, nfreeub, ncollect );
            printf( "maxnc: %zd\n", maxnc );   
        }
        
        
//         for( boost::unordered_map<size_t,size_t>::iterator it = m_msizes.begin(); it != m_msizes.end(); ++it ) {
//             printf( "s: %zd: %zd\n", it->first, it->second );    
//             
//         }    
    }
    inline void *gc_malloc( size_t s ) {
        void *ptr = std::malloc(s);
        gc_set.insert(ptr);

        maxnc = std::max( maxnc, gc_set.size() );
        ngcmalloc++;
        mstat(s);
        return ptr;
    }

    inline void gc_free( void *ptr ) {
        
        size_t n = gc_set.erase(ptr);
        
        assert( n == 1 );
        ((void)(n));
        ngcfree++;
//         printf( "gcfree: %p\n", ptr );
        std::free( ptr );

    }

//     inline void *malloc( size_t s ) {
//         nmalloc++;
//         mstat(s);
//         return std::malloc( s );
//     }
    inline void *malloc( size_t s ) {
        void *ptr = std::malloc(s);
        gc_set.insert(ptr);

        maxnc = std::max( maxnc, gc_set.size() );
        ngcmalloc++;
        mstat(s);
        return ptr;
    }
    inline void free( void *ptr ) {
        nfree++;

        size_t n = gc_set.erase(ptr);

        if ( n != 0 ) {
            nfreeub++;
        }
//         printf( "free: %p\n", ptr );
        std::free(ptr);
        //assert( gc_set.find( ptr ) == gc_set.end() );
    }
#else
    void *gc_malloc( size_t s ) {
        void *ptr = malloc(s);
        ngcmalloc++;
        return ptr;
    }

    void gc_free( void *ptr ) {


        assert( n == 1 );
        ngcfree++;
        free( ptr );

    }

    void *malloc( size_t s ) {
        nmalloc++;
        return malloc( s );
    }

    void free( void *ptr ) {
        nfree++;


        free(ptr);
        //assert( gc_set.find( ptr ) == gc_set.end() );
    }
#endif
};

class g_span_error : public std::runtime_error {
public:
    g_span_error() : std::runtime_error( "g_span_error" ) {
        
    }
    g_span_error( const char *msg ) : std::runtime_error( msg ) {
        
    }
};


class timeout_exception {};

#include <sys/time.h>



double gettime(void )
{
#ifdef WIN32
  time_t tp;
  struct tm localtm;
  tp = time(NULL);
  localtm = *localtime(&tp);
  return 60.0*localtm.tm_min + localtm.tm_sec;
#else
  struct timeval ttime;
  gettimeofday(&ttime , 0);
  return ttime.tv_sec + ttime.tv_usec * 0.000001;
#endif
}


template< class sdf_> 
struct g_span {
    
    typedef typename sdf_::atom::ele_t atom_ele_t;
    typedef typename sdf_::atom atom;
    typedef typename sdf_::bond bond;
    typedef typename sdf_::molecule molecule;
    
    class file_guard {
        FILE *m_fp;
    public:
        
        file_guard( FILE *fp ) : m_fp(fp) {}
        ~file_guard() {
            if( m_fp != 0 ) {
                fclose( m_fp );
            }
        }
        
        void close() {
            fclose( m_fp );
            m_fp = 0;
            
        }
        
        FILE *h() {
            return m_fp;
        }
        
        
    };
    
    std::vector<molecule> m_backbones;
    double end_time;
    
// move up:
    int *dfsNum;
    int *low;
    int num;
    int biCompCount;
    edgeListElementPointer * edgeStack;
    int edgeStackTop;
//
    int matchedNodeCount;// = 0;
    edgeTupelPointer bfsCode;// = NULL;
    int *originalNodeIDs;



    int ** commonEnvSize;
    int maxCommEnvSize;
    int ** distanceLevelSize;
    int nodeCount;

    edgeListElementPointer firstEdgeIt;
    edgeListElementPointer secondEdgeIt;
    edgeTupelPointer secondSiblingEdge;
    edgeListElementPointer previousEdge;// = NULL;
    edgeListElementPointer nextEdge;// = NULL;
    int viererkreisCount;// = 0;
    int mapCount;// = 0;
//
    graphPointer currentGraph;// = NULL;             /* Zeigt auf den gerade betrachteten Graphen */
    edgeTupelPointer currentEdgeTupel;// = NULL;     /* Das zuletzt hinzugef?gte Tupel in einem DFS-Code */
    int currentSubgraphSize;// = 0;                  /* Anzahl der Kanten im aktuellen Subgraph, i.e. die L?nge des dfsCode Arrays */
    int minsizeSubgraphSize;
    int maxSubgraphSize;
    int freqSubgraphCount;// = 0;         /* Zum Ermitteln der Gesamtzahl h?ufiger Subgraphen */
    int oldFreqSubgraphCount;// = 0;
//int maxFragSize;

    int nrFrags;
    int minBB;
    bool m_search_second;
    int *nodeID2RightestPathPosition;      /* Gibt zu firstNodeNr bzw. edgeStartNode->vertexID die Position des Tupels auf rechtestem Pfad */
    int *rightestPathPosition2edgeTupelNr;   /* Gibt zu einem int (Position eines Tupels im rechtesten Pfad) die Position des Tupels im */
    /* DFS Code zur?ck. (zum Bestimmen der Erweiterungen, die vom rechtesten Pfad ausgehen */
    int fw2ExtensionCount;// = 0;
    int remainingFw2Extensions;
    int *fw2ExtensionCountArray;
    int *remainingFw2ExtensionsArray;
    edgeTupelPointer *dfsCode;
    edgeTupelPointer **bwTable;
    edgeTupelPointer **fw1Table;
    edgeTupelPointer ***fw2Table;
    boolean ***fw2CandidateTable;
    edgeListElementPointer *edgeMatchList;
    superGraphPointer superGraph;// = NULL;
    graphNodePointer firstNodeOfSubgraph;// = NULL;
    graphNodePointer lastNodeOfSubgraph;// = NULL;

#ifdef DEBUG
    int removedGraphs = 0;
    int occInGraph;
    int forkCount = 0;
    int forkCount2 = 0;
    int unsuccessfulCandidateCount = 0;
#endif

#ifdef CLOCK
    clock_t startEnumEmb, stopEnumEmb;
    clock_t startMatch, stopMatch;
    double enumDur = 0;
    double matchDur = 0;
#endif

//#ifdef SYMMETRY
    int biConnCompNr;
//#endif

//#ifdef AUSGABE
    FILE *output;
//#endif


    int maxFragSize;// = -1;
    boolean useSymm;// = FALSE;
    boolean useAscFreqOrder;// = FALSE;
    boolean useEmbLists;// = FALSE;
    int hybridThreshold;// = -1;
    boolean findOnlyTrees;// = FALSE;
    boolean findOnlyPaths;// = FALSE;
    int minSup;// = -1;
    boolean createOutput;// = TRUE;
    char *filename;// = NULL;
    char *outputfile;// = NULL;
    double threshold;

    int Relabel_Dictionary_Node[MAX_NODE_TYPES];
    int Relabel_Dictionary_Edge[MAX_EDGE_TYPES];
//
// int nodeComp(graphNodePointer *index1, graphNodePointer *index2);
// graphNodePointer removeIdleNode(graphNodePointer node, graphNodePointer previousNode, graphPointer currentGraph);
// void removeEdge(edgeListElementPointer edge, graphNodePointer node);
// void sortEdgeList(graphNodePointer node);
// unsigned hash(edgeListElementPointer edge);


    int i;
    int edgeLabelFrequency[MAX_EDGE_TYPES];   /* Index ist EdgeLabel, Wert die Häufigkeit des edgeLabels */
    int nodeLabelFrequency[MAX_NODE_TYPES];   /* Index ist NodeLabel, Wert die Häufigkeit des nodeLabels */

    int unconnected;// = 0;         /* Anzahl der kantenlosen Knoten, die entfernt wurden */
    int maxNodeCount;// = 0;   /* Maximalanzahl von Knoten in einem Graphen der DB */
    int maxEdgeCount;// = 0;
    int maxNodeDegree;// = 0;
    int freedGraphs;// = 0;  /* Zählt wieviele leere Graphen aus der DB gelöscht wurden */
    int edgeLabelCount;
    int nodeLabelCount;
    int iterationsOverDB;// = 0;    /* Anzahl der DB-Durchläufe bis Konvergenz erreicht ist beim Entfernen von Knoten und Kanten */

    graphNodePointer nodeArray[MAX_NODE_NUMBER]; /* Array zum Speichern der Knoten eines Graphen, MAX_NODE_NUMBER begrenzt max. Graphgröße */
    edgeTupelPointer *oneEdgeGraphHashTable;     /* HashTable zum Erstellen der oneEdgeGraphs-Liste */

    graphDatabasePointer newDB;                  /* Pointer auf die DB, die aus Inputfile erstellt wird, wird von gSpan.c verwendet */
    edgeTupelPointer freqOneEdgeGraphs;// = NULL;   /* Pointer auf die Liste der häufigen oneEdgeGraphen, wird von gSpan.c verwendet */

#ifdef CLOCK
    clock_t start, stop;
    double duration = 0;
#endif



    gc_allocator al;
// 
/////////////////////////////////////////////////////////////
// min.cpp
/////////////////////////////////////////////////////////////
#define removeLeftLink(edge) ((edge->previousEdgeListElement) ? (edge->previousEdgeListElement->nextEdgeListElement = edge->nextEdgeListElement) : (edge->edgeStartNode->firstEdge = edge->nextEdgeListElement))

#define removeRightLink(edge) ((edge->nextEdgeListElement) ? (edge->nextEdgeListElement->previousEdgeListElement = edge->previousEdgeListElement) : NULL)

#define reinsertLeftLink(edge) ((edge->previousEdgeListElement) ? (edge->previousEdgeListElement->nextEdgeListElement = edge) : (edge->edgeStartNode->firstEdge = edge))
#define reinsertRightLink(edge) ((edge->nextEdgeListElement) ? (edge->nextEdgeListElement->previousEdgeListElement = edge) : NULL)


// extern edgeTupelPointer *dfsCode;
// extern int currentSubgraphSize;
// extern FILE *minFile;
// extern graphNodePointer firstNodeOfSubgraph;
// extern boolean findOnlyPaths;



// boolean findExtension(edgeListElementPointer edge,int i, int size, graphNodePointer matchNode[]);
// void reinsertEdge(edgeListElementPointer edge);
// void printGraph(graphPointer graph);


    bool minxxx(int size)
    {
        int originalStartID;
        int originalTargetID;
        int i;

        graphNodePointer matchNode[size+1];                                 /* Liste von Zeigern auf die gematchten Knoten im Graph */
        for (i=0; i<size+1; i++)
        {
            matchNode[i] = NULL;
        }

        graphNodePointer nodeIterator = firstNodeOfSubgraph;
        edgeListElementPointer edgeIterator = NULL;
        boolean isMinimal = TRUE;

        while (nodeIterator)           /* Iterieren über den Graph zum Finden eines kleineren DFS Codes */
        {
            if (nodeIterator->vertexLabel == dfsCode[0]->firstNodeValue)           /* Wegen prepruning kann es keine Kante im Graph */
            {                                                                       /* geben, die kleiner als die erste Kante ist. */
//                      if(findOnlyPaths)
//                      {
//                              if(nodeIterator->firstEdge)                           /* Wenn nur Pfade gesucht werden kann  es Vorkommen       /\     /  */
//                                      if(nodeIterator->firstEdge->nextEdgeListElement)  /* daß Darstellung als Baum kleiner ist als Darstellung  /      /   */
//                                      {                                                 /* als Pfad. Um keine Fragmente zu verlieren wird die          /    */
//                                              nodeIterator = nodeIterator->nextNode;        /* Suche nach kleinerern DFS Codes nur an Blättern begonnen         */
//                                              continue;
//                                      }
//                      }
                edgeIterator = nodeIterator->firstEdge;
                while (edgeIterator)
                {
                    if (edgeIterator->edgeLabel == dfsCode[0]->edgeValue)
                    {
                        if (edgeIterator->edgeTarget->vertexLabel == dfsCode[0]->secondNodeValue)   /* Startkante gefunden */
                        {
                            originalStartID = edgeIterator->edgeStartNode->vertexID;   /* Zwischenspeichern der Original-IDs */
                            originalTargetID = edgeIterator->edgeTarget->vertexID;
                            edgeIterator->edgeStartNode->vertexID = 0;                 /* Umbenennen der gematchten Knoten */
                            edgeIterator->edgeTarget->vertexID = 1;
                            matchNode[0] = edgeIterator->edgeStartNode;           /* Einfügen der gematchten Knoten in die MatchListe */
                            matchNode[1] = edgeIterator->edgeTarget;

                            isMinimal = findExtension(edgeIterator, 1, size, matchNode);  /* Finde Erweiterungen zur gematchten Kante */

                            edgeIterator->edgeStartNode->vertexID = originalStartID;   /* Zurückbenennen der Knoten im Graph */
                            edgeIterator->edgeTarget->vertexID = originalTargetID;
                            if (!isMinimal)                                           /* Wurde in der Subfunktion ein kleinerer */
                            {                                                         /* DFS Code gefunden, ist man fertig */
                                return isMinimal;                                        /* Rückgabewert ist False */
                            }
                            matchNode[0] = NULL;
                            matchNode[1] = NULL;
                        }
                    }
                    edgeIterator = edgeIterator->nextEdgeListElement;          /* .... sonst weiter mit nächster Kante ...... */
                }
            }
            nodeIterator = nodeIterator->nextNode;             /* und dann mit nächstem Knoten */
        }
        return isMinimal;                          /* Wurde kein kleinerer DFS Code gefunden, ist Rückgabewert True */
    }

    boolean findExtension(edgeListElementPointer edge, int i, int size,graphNodePointer matchNode[])
    {     /* Parameter: letzte gematchte Kante, Anzahl bereits gematchter Kanten, Größe des ganzen DFS Codes, Array mit gematchten Knoten */
        int originalID;

        /* Entferne temporär vorige Kante (und reverse Kante), damit sie nicht doppelt gefunden wird. */
        removeLeftLink(edge);
        removeRightLink(edge);
        removeLeftLink(edge->reverseEdge);
        removeRightLink(edge->reverseEdge);

        /* Teste, ob es im Graph eine Extension mit StartknotenID größer als extStartID gibt, dann wurde kleinerer DFS Code gefunden */

        int extStartID = dfsCode[i]->firstNodeNr;
        int j;

        for (j=extStartID+1; j<=size &&  matchNode[j]!=NULL; j++) /* Es werden alle Knoten des Graphen durchlaufen, die bisher gematcht */
        {                                                         /* wurden und eine höhere ID haben als der jetzt zu erweiternde Knoten. */
            if (!matchNode[j])                /* Wenn einer dieser Knoten noch eine ungematchte Kante hat, ist diese Erweiterung */
                break;                    /* kleiner als jede Erweiterung des eigentlich zuerweiternden Knoten, also insb. kleiner als */
            if (matchNode[j]->firstEdge)    /* das nächste Tupel im DFS Code. Damit ist der DFS Code nicht minimal. Sobald eine KnotenID  */
            {                                /* nicht vergeben ist, ist man mit allen bisher gematchten Knoten durch, for-Schleife kann */
                reinsertLeftLink(edge);      /* abgebrochen werden, nachdem entfernte Kante wieder eingefügt wurde */
                reinsertRightLink(edge);
                reinsertLeftLink(edge->reverseEdge);
                reinsertRightLink(edge->reverseEdge);
                return FALSE;
            }
        }

        /* Durchlaufen der Kantenliste des Knotens der dem Startknoten des neuen Tupels entspricht und Suchen nach kleinerer Kante */

        edgeListElementPointer edgeIterator = NULL;
        edgeIterator = matchNode[extStartID]->firstEdge;
//         boolean breaked = FALSE;

        while (edgeIterator)
        {
            if (edgeIterator->edgeTarget->vertexID >= 0)                             /* Wenn Kante backwardedge ist und ... */
            {
                if (edgeIterator->edgeTarget->vertexID < dfsCode[i]->secondNodeNr) /*  DFS Tupel keine oder kürzere backwardedge ist, ... */
                {
                    reinsertEdge(edge);
                    return FALSE;                                                    /* ... dann ist der DFS Code nicht minimal */
                }
                if (edgeIterator->edgeTarget->vertexID == dfsCode[i]->secondNodeNr)  /* Wenn Kante und DFS Tupel gleich sind */
                {
                    if (i+1<size)
                    {
                        if (!findExtension(edgeIterator, i+1, size, matchNode))      /* Rekursiver Aufruf */
                        {
                            reinsertEdge(edge);
                            return FALSE;              /* Wenn im rekursiven Aufruf kleinerer DFS Code gefunden wurde ist man fertig */
                        }
                    }
                    edgeIterator = edgeIterator->nextEdgeListElement;     /* sonst kann mit dieser Kante DFS Code nicht unterboten werden */
                    continue;                                               /* versuche die nächste Kante */
                }
                else                         /* Kante ist größer als DFS Tupel */
                {
                    edgeIterator = edgeIterator->nextEdgeListElement;       /* mit dieser Kante kann DFS Code nicht unterboten werden */
                    continue;
                }
            }
            else                 /* Betrachtete Kante im Graphen ist forward edge */
            {
                if (dfsCode[i]->secondNodeNr < dfsCode[i]->firstNodeNr) /* DFS Tupel ist backward edge, aber Erweiterung ist forward edge */
                {                                                       /* DFS Code kann mit diesem Matching nicht unterboten werden */
                    edgeIterator = edgeIterator->nextEdgeListElement;
                    continue;
                }
                if (edgeIterator->edgeLabel < dfsCode[i]->edgeValue) /* Erweiterung kleiner als DFS Tupel, also DFS Code nicht minimal */
                {
                    reinsertEdge(edge);
                    return FALSE;              /* kleinerer DFS-Code gefunden */
                }
                if (edgeIterator->edgeLabel == dfsCode[i]->edgeValue)
                {
                    if (edgeIterator->edgeTarget->vertexLabel < dfsCode[i]->secondNodeValue) /* Erweiterung kleiner als DFS Tupel, ... */
                    {
                        reinsertEdge(edge);
                        return FALSE;         /* kleinerer DFS-Code gefunden */
                    }
                    if (edgeIterator->edgeTarget->vertexLabel == dfsCode[i]->secondNodeValue)       /* Kante und DFS Tupel sind gleich groß */
                    {
                        originalID = edgeIterator->edgeTarget->vertexID;                    /* Umbenennen des neu gematchten Knoten */
                        edgeIterator->edgeTarget->vertexID = dfsCode[i]->secondNodeNr;
                        matchNode[edgeIterator->edgeTarget->vertexID] = edgeIterator->edgeTarget;
                        if (i+1 < size)
                        {
                            if (!findExtension(edgeIterator, i+1, size, matchNode))                       /* Rekursiver Aufruf */
                            {
                                edgeIterator->edgeTarget->vertexID = originalID;
                                reinsertEdge(edge);
                                return FALSE;         /* Wenn im rekursiven Aufruf kleinerer DFS Code gefunden wurde ist man fertig */
                            }
                        }
                        matchNode[edgeIterator->edgeTarget->vertexID] = NULL;
                        edgeIterator->edgeTarget->vertexID = originalID;
                    }
                }
                edgeIterator = edgeIterator->nextEdgeListElement;   /* Noch keine kleinere Kante gefunden. Teste die nächste Kante */
            }
        }
        reinsertEdge(edge);         /* Wiedereinfügen der vorigen Kante */

        return TRUE; /* Wurde keine kleinere Extension gefunden, wird TRUE zurückgegeben */
    }


    void reinsertEdge(edgeListElementPointer edge)
    {
        edgeListElementPointer reverseEdge = edge->reverseEdge;
        if (edge->previousEdgeListElement)
            edge->previousEdgeListElement->nextEdgeListElement = edge;
        else
            edge->edgeStartNode->firstEdge = edge;
        if (edge->nextEdgeListElement)
            edge->nextEdgeListElement->previousEdgeListElement = edge;
        if (reverseEdge->previousEdgeListElement)
            reverseEdge->previousEdgeListElement->nextEdgeListElement =  reverseEdge;
        else
            reverseEdge->edgeStartNode->firstEdge = reverseEdge;
        if (reverseEdge->nextEdgeListElement)
            reverseEdge->nextEdgeListElement->previousEdgeListElement = reverseEdge;
    }

    void printGraph(graphPointer graph)
    {
        graphNodePointer nodeIterator = graph->firstNode;
        edgeListElementPointer edgeIterator;
        while (nodeIterator)
        {
            printf("%d: ",nodeIterator->vertexID);
            edgeIterator = nodeIterator->firstEdge;
            while (edgeIterator)
            {
                printf("-%d->%d) ",edgeIterator->edgeLabel, edgeIterator->edgeTarget->vertexLabel);
                edgeIterator = edgeIterator->nextEdgeListElement;
            }
            printf("\n");
            nodeIterator = nodeIterator->nextNode;
        }
    }



/////////////////////////////////////////////////////////////
// preprocessDB2.cpp
////////////////////////////////////////////////////////////
// edgeTupelPointer lookup(edgeListElementPointer edge);
// edgeTupelPointer install(edgeListElementPointer edge, graphPointer currentGraph);
// int edgeFreqComp(int *index1, int *index2);
// int nodeFreqComp(int *index1, int *index2);
// int edgeComp(edgeListElementPointer *edge1, edgeListElementPointer *edge2);

// int nodeComp(graphNodePointer *index1, graphNodePointer *index2);
// graphNodePointer removeIdleNode(graphNodePointer node, graphNodePointer previousNode, graphPointer currentGraph);
// void removeEdge(edgeListElementPointer edge, graphNodePointer node);
// void sortEdgeList(graphNodePointer node);
// unsigned hash(edgeListElementPointer edge);
//
//
// int i;
// int edgeLabelFrequency[MAX_EDGE_TYPES];   /* Index ist EdgeLabel, Wert die Häufigkeit des edgeLabels */
// int nodeLabelFrequency[MAX_NODE_TYPES];   /* Index ist NodeLabel, Wert die Häufigkeit des nodeLabels */
//
// int unconnected = 0;         /* Anzahl der kantenlosen Knoten, die entfernt wurden */
// int maxNodeCount = 0;   /* Maximalanzahl von Knoten in einem Graphen der DB */
// int maxEdgeCount = 0;
// int maxNodeDegree = 0;
// int freedGraphs = 0;  /* Zählt wieviele leere Graphen aus der DB gelöscht wurden */
// int edgeLabelCount;
// int nodeLabelCount;
// int iterationsOverDB = 0;    /* Anzahl der DB-Durchläufe bis Konvergenz erreicht ist beim Entfernen von Knoten und Kanten */
//
// graphNodePointer nodeArray[MAX_NODE_NUMBER]; /* Array zum Speichern der Knoten eines Graphen, MAX_NODE_NUMBER begrenzt max. Graphgröße */
// edgeTupelPointer *oneEdgeGraphHashTable;     /* HashTable zum Erstellen der oneEdgeGraphs-Liste */
//
// graphDatabasePointer newDB;                  /* Pointer auf die DB, die aus Inputfile erstellt wird, wird von gSpan.c verwendet */
// edgeTupelPointer freqOneEdgeGraphs = NULL;   /* Pointer auf die Liste der häufigen oneEdgeGraphen, wird von gSpan.c verwendet */
//
// #ifdef CLOCK
// clock_t start, stop;
// double duration = 0;
// #endif

    /********************* Externe Variablen *************/

// extern int minSup;
// extern boolean useAscFreqOrder;
// extern boolean useSymm;
    int xxxx;
    /****************************************************************************/
    struct edge_freq_comp_t {
        g_span &m_gsp;
        edge_freq_comp_t( g_span &gsp ) : m_gsp(gsp) {}
        
        bool operator() (int index1,int index2) {
//             printf( "xxxx: %d\n", m_gsp.xxxx );
            if (m_gsp.useAscFreqOrder)
            {
                return m_gsp.edgeLabelFrequency[index1] < m_gsp.edgeLabelFrequency[index2];
                
            }
            //#else
            else
            {
                return m_gsp.edgeLabelFrequency[index1] > m_gsp.edgeLabelFrequency[index2]; // REMEMBER: >= is a BUG!
//                     if (edgeLabelFrequency[*index1] > edgeLabelFrequency[*index2]) return -1;
            }
                
        }
    };
    
    struct node_freq_comp_t {
        g_span &m_gsp;
        node_freq_comp_t( g_span &gsp ) : m_gsp(gsp) {
//             for( int i = 0; i < MAX_NODE_TYPES; i++ ) {
//                 printf( "nlf: %d\n", m_gsp.nodeLabelFrequency[i] );   
//                 
//             }
            
            
        }
        
        bool operator()(int index1, int index2)
        {
//              printf( "xxxx: %d\n", m_gsp.xxxx );
            //#ifdef ASCFREQ
            if (m_gsp.useAscFreqOrder)
            {
                return m_gsp.nodeLabelFrequency[index1] < m_gsp.nodeLabelFrequency[index2];
//                 if (nodeLabelFrequency[*index1] < nodeLabelFrequency[*index2]) return -1;
//                 if (nodeLabelFrequency[*index1] > nodeLabelFrequency[*index2]) return 1;
            }
            //#else
            else
            {
                return m_gsp.nodeLabelFrequency[index1] > m_gsp.nodeLabelFrequency[index2]; // REMEMBER: >= is a BUG!
//                 if (nodeLabelFrequency[*index1] < nodeLabelFrequency[*index2]) return 1;
//                 if (nodeLabelFrequency[*index1] > nodeLabelFrequency[*index2]) return -1;
            }
            //#endif
            return 0;
        }  
    };
//     graphDatabasePointer preprocessDB(const char *filename_)
//     {
//         /****************** Einlesen des Files *****************************/
// 
// //         std::vector<char> fn(filename_,filename_+strlen(filename_)+1); 
// //         char *filename = fn.data();
// //         char c;
// //         FILE *f1;
// //         file_guard fg( fopen(filename,"r"));
// //         f1 = fg.h();
// 
//         std::ifstream is(filename_);
// 
//         return preprocessDB(is);
//     }
//     
//     graphDatabasePointer preprocessDB(std::istream &is) {
//     //graphDatabasePointer preprocessDB(FILE *f1) {
//         //char* fileSplit = NULL;
//         
//         char *r;
//         //fileSplit = strtok_r(filename, ".", &r);
// 
// //         if (f1==NULL)
// //         {
// //             fprintf(stderr,"Can't open input file\n");
// //         }
//         const size_t line_len = 100;
//         char line[line_len];    /* Zum Einlesen der Zeilen des Files */
// 
//         newDB = (graphDatabasePointer)al.malloc(sizeof(graphDatabase)); /* Erzeuge leere Graphdatenbank */
// #ifdef DEBUG
//         if (!newDB)
//         {
//             fprintf(stderr,"Not enough memory for new 'graphDatabase'.\n");
//             throw g_span_error;
//         }
// #endif
//         newDB->databaseNr = 1;
//         newDB->numberOfGraphsInDB = 0;
//         newDB->firstGraphInDB = NULL;                                  /* GraphDB initialisiert */
// 
//         int graphNr = 0;         /* Zum Zuweisen der ID der Graphen, Bestimmen der Gesamtzahl der Graphen */
// 
//         graphPointer newGraph = NULL;
//         graphPointer previousGraph = NULL;
//         graphNodePointer newNode = NULL;
//         graphNodePointer previousNode = NULL;
//         graphNodePointer nodeIterator = NULL;
//         edgeListElementPointer newEdge1;
//         edgeListElementPointer newEdge2;
// 
//         int lineNumber = 0;
//         int firstNodeID, secondNodeID, edgeLabel;
// 
//         
//         is.getline(line,line_len);
//             
// //                 if( (is.rdstate() & is.eofbit) != 0 ) {
// //                     printf( "eof\n" );
// //                     break;
// //                     
// //                 }
//         while( !is.eof() )
//         {
//             
// //             printf( "line: %s\n", line );
//             lineNumber++;
//             
//             if( line[0] == 'x' ) {
//                 //printf( "read x, exit\n" );
//                 break;
//             }
//             if (line[0] == 't')           /* Neuer Graph beginnt */
//             {
// //                 printf( "new graph\n" );
//                 newGraph = (graphPointer)al.gc_malloc(sizeof(graphFromDB));  /* Erzeuge neuen Graph */
//                 if (!newGraph)
//                     fprintf(stderr,"Not enough memory for new 'graphFromDB'.\n");
//                 previousNode = NULL;
//                 (newDB->numberOfGraphsInDB)++;
//                 if (previousGraph)
//                 {
//                     previousGraph->nextGraph = newGraph;
//                     newGraph->previousGraph = previousGraph;
//                 }
//                 else                                            /* Wenn der Graph der erste in der DB ist */
//                 {
//                     newDB->firstGraphInDB = newGraph;
//                     newGraph->previousGraph = NULL;
//                 }
// 
//                 previousGraph = newGraph;
//                 newGraph->graphNr = graphNr;
//                 newGraph->nodeMapCount = 0;
//                 newGraph->nextGraph = NULL;
// 
// #ifdef DEBUG
//                 if (graphNr != atoi(line+4))    /* Test ob die interne Zählung der Graphen und die im Graph-File übereinstimmen */
//                 {
//                     fprintf(stderr,"Graph number problem %d %d.\n",graphNr, atoi(line+4));
//                     throw g_span_error;
//                 }
// #endif
// 
//                 graphNr++;
// 
//                 while (true) /* Einlesen der Knoten des neuen Graphen */
//                 {
//                     //fgets(line, 100, f1) != NULL && lineNumber++ && line[0] == 'v'
//                     
//                     is.getline( line, line_len );
//                     lineNumber++;
//                     
//                     if( line[0] != 'v' ) {
//                         break;
//                         
//                     }
//                     
//                     char *r;
//                     lineNumber++;
//                     newNode = (graphNodePointer)al.gc_malloc(sizeof(graphNode));  /* Erzeuge neuen Knoten */
//                     if (!newNode)
//                         fprintf(stderr,"Not enough memory for new 'graphNode'.\n");
// 
//                     strtok_r(line," ",&r);                               /* line besteht aus 3 Token: 'v', 'Knoten-Nr', 'Knoten-Label' */
//                     newNode->vertexID = -(atoi(strtok_r(NULL," ",&r))+1);/* vertexId soll für ungematchte Knoten negativ sein (+1 wg. 0) */
//                     newNode->vertexLabel = atoi(strtok_r(NULL," ",&r));     /* Label des Knotens */
//                     newNode->nextNode = NULL;
//                     newNode->firstEdge = NULL;
//                     newNode->smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding = -1;
//                     newNode->altStartNode = 0; /* die IDs sind alle negativ */
//                     nodeLabelFrequency[newNode->vertexLabel]++;  /* Häufigkeit des KnotenLabels hochsetzen */
// 
//                     if (previousNode)
//                     {
//                         previousNode->nextNode = newNode;
//                     }
//                     else
//                     {
//                         newGraph->firstNode = newNode;
//                     }
//                     previousNode = newNode;
//                 }
//                 for (i=0,nodeIterator=newGraph->firstNode; nodeIterator && i<MAX_NODE_NUMBER; nodeIterator=nodeIterator->nextNode,i++)
//                 {
//                     nodeArray[i] = nodeIterator;  /* Zum Erzeugen der Kanten aus IDs von Start- und Zielknoten */
//                 }                                 /* Index ist ID des Files, nicht die (negative) ID der GraphDB */
// 
//                 std::string line_safe( line );
//                 if (line[0] == 'e') /* Sonst gibt es gar keine Kanten in diesem Graph */
//                 {
//                     do
//                     {
//                         newEdge1 = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));
//                         newEdge2 = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));
//                         if (!newEdge1 || !newEdge2)
//                         {
//                             fprintf(stderr,"Not enough memory for new 'edgeListElement'.\n");
//                         }
//                         char *r;
//                         
//                         strtok_r(line," ",&r);  /* line besteht aus 4 Token: 'e', 'Nr des 1.Knotens', Nr des 2.Knotens','Kanten-Label' */
//                         firstNodeID = atoi(strtok_r(NULL," ", &r));     /* ID des ersten Knoten, d.h hier Index im nodeArray */
//                         secondNodeID = atoi(strtok_r(NULL," ",&r));    /* ID des zweiten Knoten, d.h hier Index im nodeArray */
//                         
//                         char *tok = strtok_r(NULL," ", &r);
//                         
//                         if( tok == 0 ) {
//                          
//                             printf( "gspan parsing fuckup: '%s'\n", line_safe.c_str() );
//                         }
//                         edgeLabel = atoi(tok);       /* Label der Kante */
// 
//                         newEdge1->edgeLabel = edgeLabel;
//                         newEdge2->edgeLabel = edgeLabel;
//                         newEdge1->edgeStartNode = nodeArray[firstNodeID];
//                         newEdge2->edgeStartNode = nodeArray[secondNodeID];
//                         newEdge1->edgeTarget = nodeArray[secondNodeID];
//                         newEdge2->edgeTarget = nodeArray[firstNodeID];
//                         newEdge1->edgeTargetValue = (nodeArray[secondNodeID])->vertexLabel;
//                         newEdge2->edgeTargetValue = (nodeArray[firstNodeID])->vertexLabel;
// 
//                         if ((nodeArray[firstNodeID])->firstEdge)
//                             (nodeArray[firstNodeID])->firstEdge->previousEdgeListElement = newEdge1;
//                         if ((nodeArray[secondNodeID])->firstEdge)
//                             (nodeArray[secondNodeID])->firstEdge->previousEdgeListElement = newEdge2;
// 
//                         newEdge1->previousEdgeListElement = NULL;
//                         newEdge2->previousEdgeListElement = NULL;
//                         newEdge1->reverseEdge = newEdge2;
//                         newEdge2->reverseEdge = newEdge1;
//                         newEdge1->biconnCompNr = -1;
//                         newEdge2->biconnCompNr = -1;
//                         newEdge1->visited = FALSE;
//                         newEdge2->visited = FALSE;
//                         newEdge1->isNotEquivalent = FALSE;
//                         newEdge2->isNotEquivalent = FALSE;
//                         newEdge1->nextEdgeListElement = (nodeArray[firstNodeID])-> firstEdge;
//                         newEdge2->nextEdgeListElement = (nodeArray[secondNodeID])-> firstEdge;
// 
//                         (nodeArray[firstNodeID])-> firstEdge = newEdge1;
//                         (nodeArray[secondNodeID])-> firstEdge = newEdge2;
//                         edgeLabelFrequency[edgeLabel]++;
//                         
//                         is.getline( line, line_len );
//                         
//                         if( line[0] != 'e' || is.eof() ) {
//                             break;
//                         }
//                     } while(true);
//                     //while (fgets(line, 100, f1) != NULL && lineNumber++ && line[0] == 'e');
//                 }
//             } else {
//              
//                 throw g_span_error("missing start of graph");
//             }
// 
//         }
//         
//    
//         
// #ifdef DEBUG
//         printf("Reading of input file finished.\n");
// #endif
// 
//         /* GraphDB vollständig eingelesen. Die Arrays edgeLabelFrequency und nodeLabelFrequency speichern die Häufigkeit der */
//         /* verschiedenen Labels. Jetzt Entfernen von leeren Graphen, kantenlosen Knoten, nichthäufigen Kanten und nichthäufigen */
//         /* Knoten samt ihren Kanten */
// 
//         /* Bestimmen der Anzahl der tatsächlich vorkommenden Kanten- und Knotenlabels*/
// 
//         int edgeLabelTypes = 0;
//         int nodeLabelTypes = 0;
//         int k;
// 
//        
//         for (k=0; k<MAX_EDGE_TYPES && edgeLabelFrequency[k]>0; k++) /* Zweite Abbruchbedingung wg. Annahme, daß Label keine Lücken haben */
//         {
//             edgeLabelTypes++;
//         }
// 
//         for (k=0; k<MAX_NODE_TYPES && nodeLabelFrequency[k]>0; k++)
//         {
//             nodeLabelTypes++;
//         }
//         
//         
// #ifdef DEBUG
//         printf("Number of edge label types: %d\n",edgeLabelTypes);
//         printf("Number of node label types: %d\n",nodeLabelTypes);
// #endif
// 
//         /* Durchlaufen der DB zum Entfernen nichthäufiger Elemente */
// 
//         graphPointer currentGraph = NULL;  /* Iterator über die Graphen der DB */
//         previousGraph = NULL;
// 
//         graphNodePointer m = NULL;
//         edgeListElementPointer n = NULL;
//         previousNode = NULL;
//         graphNodePointer tempNode = NULL;
//         edgeListElementPointer previousEdge = NULL;
//         edgeListElementPointer tempEdge = NULL;
//         currentGraph = newDB->firstGraphInDB;     /*Zeigt auf den aktuell betrachteten graph der DB */
//         boolean unchanged = FALSE;    /* Wird auf TRUE gesetzt , sobald ein Durchlauf durch DB ohne Änderungen erfolgte */
// 
//         while (!unchanged)
//         {
//             unchanged = TRUE;
//             iterationsOverDB++;                                     /* Summiert über die Anzahl der DB Durchläufe */
//             previousGraph = NULL;
//             currentGraph = newDB->firstGraphInDB;
//             while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
//             {
//                 if (currentGraph->firstNode == NULL)      /* Entferne leere Graphen aus DB */
//                 {
//                     if (previousGraph)
//                     {
//                         previousGraph->nextGraph = currentGraph->nextGraph;
//                         al.free(currentGraph);
//                         freedGraphs++;
//                         currentGraph = previousGraph->nextGraph;
//                     }
//                     else
//                     {
//                         newDB->firstGraphInDB = currentGraph->nextGraph;
//                         al.free(currentGraph);
//                         freedGraphs++;
//                         currentGraph = newDB->firstGraphInDB;
//                     }
//                     continue;
//                 }
//                 m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
//                 previousNode = NULL;
// 
//                 while (m)                          /*Iterieren ?ber die Knoten des Graphen */
//                 {
//                     if (!(m->firstEdge))          /* Knoten ohne Kanten sollen entfernt werden */
//                     {
//                         unconnected++;                             /* Zählt Knoten, die entfernt werden, weil sie keine Kanten haben */
//                         nodeLabelFrequency[m->vertexLabel]--;                            /* Aktualisiere Häufigkeit des Knotenlabels */
//                         m = removeIdleNode(m, previousNode, currentGraph);                    /* Entfernt den (kantenlosen) Knoten */
//                         unchanged = FALSE;                /* Weiterer Durchlauf nötig, z.B könnte Knotentyp von m nichthäufig werden */
//                         continue;
//                     }
//                     if (nodeLabelFrequency[m->vertexLabel] < minSup)  /* Wenn Knoten nicht häufig ist, soll er gelöscht werden */
//                     {
//                         unchanged = FALSE;     /* Weiterer DB Durchlauf nötig, z.B könnte ein Zielknoten des Knotens kantenlos werden */
// 
//                         if (previousNode)               /* Aktualisieren der Pointer in der Knotenliste, Knoten m wird später entfernt*/
//                         {
//                             previousNode->nextNode = m->nextNode;
//                         }
//                         else
//                         {
//                             currentGraph->firstNode = m->nextNode;
//                         }
// 
//                         n = m->firstEdge;
// #ifdef DEBUG
//                         if (!n)                    /* Dieses Prädikat sollte niemals erfüllt sein */
//                         {
//                             fprintf(stderr,"Knoten %d hat keine kanten\n", m->vertexID);
//                             fprintf(stderr,"FEHLER!!!!!!!!!!\n");
//                             throw g_span_error;;
//                         }
// #endif
// 
//                         while (n)   /* Bevor m gelöscht wird, sollen alle Kanten, die von Knoten m ausgehen gelöscht werden */
//                         {
//                             tempEdge = n->nextEdgeListElement;
//                             edgeLabelFrequency[n->edgeLabel]--;          /* Dekrementiere Häufigkeit des Kantentyps */
//                             removeEdge(n->reverseEdge,n->edgeTarget);
//                             removeEdge(n,m);
//                             n  = tempEdge;
//                         }
//                         tempNode = m;
//                         (nodeLabelFrequency[m->vertexLabel])--;             /* Dekrementiere Häufigkeit des Knotentyps*/
//                         m=m->nextNode;
//                         al.free(tempNode);                              /* Lösche nichthäufigen Knoten m */
//                     }
//                     else         /* Wenn der Knoten m häufig war, iteriere über seine Kanten. Nichthäufige Kanten sollen gelöscht werden */
//                     {
//                         n = m->firstEdge;
//                         tempEdge = NULL;
//                         while (n)              /* Kanten mit Häufigkeit < minSup sollten gelöscht werden */
//                         {
//                             tempEdge = n->nextEdgeListElement;
// 
//                             if (edgeLabelFrequency[n->edgeLabel] < minSup)
//                             {
//                                 unchanged = FALSE;                       /* Zielknoten könnte z.B kantenlos werden */
//                                 removeEdge(n->reverseEdge,n->edgeTarget);
//                                 removeEdge(n,m);      /* Rückrichtung braucht nicht gesucht werden. Wird vom Zielknoten aus gefunden */
//                             }
//                             n = tempEdge;
//                         }
//                         previousNode = m;
//                         m = m->nextNode;
//                     }
//                 }
//                 previousGraph = currentGraph;
//                 currentGraph = currentGraph -> nextGraph;
//             }
//         }
// #ifdef DEBUG
//         printf("Processing step 1 finished\n");
// #endif
// 
//         /******** Jetzt enthält GraphDB nur noch häufige Knoten und Kanten und alle Knoten haben mind. eine Kante   ***********/
// 
//         /* Sortieren der Kanten- und Knotenlabels nach Häufigkeit, über ein int-Array, dessen Indizes die ursprünglichen Labels der */
//         /* Kanten und Knoten darstellen und deren Werte die neuen Labels nach Sortierung nach Häufigkeit des Vorkommens darstellen */
// 
//         int freqSortedEdgeLabels[edgeLabelTypes];   /* Länge des Arrays ist Anzahl der tatsächlich vorkommenden Kantenlabels */
//         int freqSortedNodeLabels[nodeLabelTypes];   /* Länge des Arrays ist Anzahl der tatsächlich vorkommenden Knotenlabels */
// 
//         for (k=0; k<edgeLabelTypes; k++)
//         {
//             freqSortedEdgeLabels[k] = k;         /* Initialisiere Array mit ursprünglichem Label */
//         }
//         for (k=0; k<nodeLabelTypes; k++)
//         {
//             freqSortedNodeLabels[k] = k;         /* Initialisiere Array mit ursprünglichem Label */
//         }
// 
// 
//         typedef int (*qsort_cmp_t)(const void *, const void *);
//         
//         
//         edge_freq_comp_t edge_freq_comp(*this);
//         node_freq_comp_t node_freq_comp(*this);
//         
// //         bool bla = edge_freq_comp(1,2);
//         //std::sort<int *, edge_freq_comp_t>((int*)freqSortedEdgeLabels, (int*)freqSortedEdgeLabels+edgeLabelTypes, edge_freq_comp);
//         std::sort((int*)freqSortedEdgeLabels, (int*)freqSortedEdgeLabels+edgeLabelTypes, edge_freq_comp);
//         //qsort(freqSortedEdgeLabels,edgeLabelTypes,sizeof(int),(qsort_cmp_t)edgeFreqComp); /* Sortieren der Kantenlabels nach Häufigkeit */
//         //qsort(freqSortedNodeLabels,nodeLabelTypes,sizeof(int),(qsort_cmp_t)nodeFreqComp); /* Sortieren der Knotenlabels nach Häufigkeit */
//         std::sort((int*)freqSortedNodeLabels,(int*)freqSortedNodeLabels+nodeLabelTypes, node_freq_comp); /* Sortieren der Knotenlabels nach Häufigkeit */
// 
//         
//         /* freqSortedEdgeLabels[k] entspricht: Welches ist das k-häufigste edgeLabel? */
//         int freqSortedEdgeLabels2[edgeLabelTypes];   /* Länge des Arrays ist Anzahl der tatsächlich vorkommenden Kantenlabels */
//         int freqSortedNodeLabels2[nodeLabelTypes];   /* Länge des Arrays ist Anzahl der tatsächlich vorkommenden Knotenlabels */
// 
//         for (k=0; k<edgeLabelTypes; k++)
//         {
//             freqSortedEdgeLabels2[freqSortedEdgeLabels[k]] = k;         /* Initialisiere Array mit ursprünglichem Label */
//         }
//         for (k=0; k<nodeLabelTypes; k++)
//         {
//             freqSortedNodeLabels2[freqSortedNodeLabels[k]] = k;         /* Initialisiere Array mit ursprünglichem Label */
//         }
// 
//         /*********************** Schreibe File mit den Umnummerierungen der Knoten und Kantenlabels **************/
//         /*FILE *relabeled;
// 
//         strcat(fileSplit,".txt");
//         relabeled = fopen(fileSplit,"w");
//         //relabeled = fopen("relabeled.txt","w");
// 
//         // freqSortedEdgeLabels2[x] entspricht: Das wieviel häufigste edgeLabel ist x?
//         fprintf(relabeled, "edgeLabels\n");
//         fprintf(relabeled, "fID oID\n");
//         for(k=0; k<edgeLabelTypes; k++)
//         {
// 
//             fprintf(relabeled,"%d    %d \n",k,freqSortedEdgeLabels[k]);
//         }
//         fprintf(relabeled, "\nnodeLabels\n");
//         fprintf(relabeled, "fID oID\n");
//         for(k=0; k<nodeLabelTypes; k++)
//         {
//             fprintf(relabeled,"%d %d\n",k,freqSortedNodeLabels[k]);         // Initialisiere Array mit ursprünglichem Label
//         }
//         fclose(relabeled);
//         */
//         /* Durchlaufe GraphDB zum Relabeln der Knoten */
// 
//         previousGraph = NULL;
//         currentGraph = newDB->firstGraphInDB;
//         printf( "blub: %p\n", currentGraph );
//         while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
//         {
//             m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
//             previousNode = NULL;
//             while (m)                          /*Iterieren ?ber die Knoten des Graphen */
//             {
//                 
//                 m->vertexLabel = freqSortedNodeLabels2[m->vertexLabel];  /* Relabeln der Knoten nach Häufigkeit */
//                 
//                 printf( "relable: %p %d\n", m, m->vertexLabel );
//                 m=m->nextNode;
//             }
//             currentGraph = currentGraph -> nextGraph;
//         }
// 
//         oneEdgeGraphHashTable = (edgeTupelPointer*)al.malloc(nodeLabelTypes*sizeof(edgeTupelPointer)); /* HashTable für oneEdgeGraphen */
// 
//         for (k=0;k<nodeLabelTypes;k++)
//         {
//             oneEdgeGraphHashTable[k] = NULL;
//         }
// 
//         /* Durchlaufe GraphDB zum Relabeln der Kanten und Bestimmen der häufigen OneEdgeGraphs */
// 
//         previousGraph = NULL;
//         currentGraph = newDB->firstGraphInDB;
// 
//         while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
//         {
//             m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
//             previousNode = NULL;
// 
//             while (m)                          /*Iterieren ?ber die Knoten des Graphen */
//             {
//                 n = m->firstEdge;
//                 while (n)   /* Iterieren über die Kanten von m */
//                 {
//                     n->edgeLabel = freqSortedEdgeLabels2[n->edgeLabel];             /* Relabeln der Kanten nach Häufigkeit */
//                     n->edgeTargetValue = n->edgeTarget->vertexLabel;
//                     if (n->edgeTargetValue < m->vertexLabel)         /* Kante nicht minimal */
//                     {
//                         n = n->nextEdgeListElement;                 /* Gehe zur nächsten Kante */
//                         continue;
//                     }
//                     install(n,currentGraph); /* Füge Kante in die HashTabelle der oneEdgeGraphen ein */
//                     n = n->nextEdgeListElement;
//                 }
//                 m=m->nextNode;
//             }
//             currentGraph = currentGraph -> nextGraph;
//         }
// 
//         /* Durchlaufe HashTabelle der oneEdgeGraphen, entferne seltene oneEdgeGraphen und verbinde die oneEdgeGraph-Listen */
// 
//         edgeTupelPointer edgeTupelIterator = NULL;
//         edgeTupelPointer previousEdgeTupel = NULL;
//         edgeTupelPointer tempEdgeTupelIterator = NULL;
//         int freqOneEdgeGraphsCount = 0;
// 
//         for (k=0; k<nodeLabelTypes;k++)
//         {
//             edgeTupelIterator = oneEdgeGraphHashTable[k];
//             while (edgeTupelIterator)
//             {
//                 if (edgeTupelIterator->occurrences >= minSup)
//                 {
//                     freqOneEdgeGraphsCount++;
//                     if (previousEdgeTupel)
//                     {
//                         edgeTupelIterator->previousEdgeTupel = previousEdgeTupel;
//                         previousEdgeTupel->nextEdgeTupel = edgeTupelIterator;
//                     }
//                     else
//                     {
//                         freqOneEdgeGraphs = edgeTupelIterator;    /* Erstes Element der Liste gefunden */
//                     }
//                     previousEdgeTupel = edgeTupelIterator;
//                     edgeTupelIterator=edgeTupelIterator->nextEdgeTupel;
//                 }
//                 else
//                 {
//                     if (previousEdgeTupel)
//                     {
//                         previousEdgeTupel->nextEdgeTupel = NULL;
//                     }
//                     if (oneEdgeGraphHashTable[k] == edgeTupelIterator)
//                     {
//                         oneEdgeGraphHashTable[k] = edgeTupelIterator->nextEdgeTupel;
//                     }
//                     tempEdgeTupelIterator = edgeTupelIterator;
//                     edgeTupelIterator = edgeTupelIterator->nextEdgeTupel;
// #ifdef DEBUG
//                     printf("infrequent tuple: (%d,%d,%d,%d,%d) \n", tempEdgeTupelIterator->firstNodeNr, tempEdgeTupelIterator->secondNodeNr,
//                            tempEdgeTupelIterator->firstNodeValue, tempEdgeTupelIterator->edgeValue, tempEdgeTupelIterator->secondNodeValue) ;
// #endif
//                     removeSupergraphList(tempEdgeTupelIterator);
//                     al.free(tempEdgeTupelIterator);
//                 }
//             }
//         }
// #ifdef DEBUG
//         printf("number of frequent one edge graphs: %d\n", freqOneEdgeGraphsCount);
//         printf("Processing step 2 finished\n");
// #endif
// 
//         /* Entferne nichthäufige oneEdgeSubgraphen aus GraphDB, erzeuge SuperGraphListe der häufigen oneEdgeGraphen */
// 
//         previousGraph = NULL;
//         currentGraph = newDB->firstGraphInDB;
//         int edgeCount;
//         int nodeDegree;
//         int j;
// 
//         while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
//         {
//             m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
//             previousNode = NULL;
//             edgeCount = 0;
// 
//             while (m)                          /*Iterieren ?ber die Knoten des Graphen */
//             {
//                 n = m->firstEdge;
//                 nodeDegree = 0;
//                 while (n)   /* Iterieren über die Kanten von m */
//                 {
//                     nodeDegree++;
//                     if (n->edgeTargetValue < m->vertexLabel)       /* Kante nicht minimal ->die reverse edge wird stattdessen überprüft */
//                     {
//                         n = n->nextEdgeListElement;                 /* Gehe zur nächsten Kante */
//                         continue;
//                     }
// 
//                     /* Finden der Kante in Liste der oneEdgeGraphen, bedeutet Kante ist häufig. Dann Graph in SuperGraphListe einfügen*/
//                     /* Sonst nicht häufig: Entfernen der Kante aus DB.Dadurch können wieder Knoten ohne Kanten entstehen. Aber wenn  */
//                     /* ein Knoten dadurch selten wird, dann ist er nach dem vollst. Durchlauf unconnected. Es genügt ein weiterer   */
//                     /* Durchlauf um solche Knoten zu entfernen */
// 
//                     if (oneEdgeGraphHashTable[m->vertexLabel])
//                     {
//                         edgeTupelIterator = oneEdgeGraphHashTable[m->vertexLabel];
//                         while (edgeTupelIterator)
//                         {
//                             if (edgeTupelIterator->firstNodeValue == m->vertexLabel)
//                             {
//                                 if (edgeTupelIterator->edgeValue == n->edgeLabel)
//                                 {
//                                     if (edgeTupelIterator->secondNodeValue== n->edgeTarget->vertexLabel)
//                                     {
//                                         break;
//                                     }
//                                 }
//                                 edgeTupelIterator = edgeTupelIterator->nextEdgeTupel;
//                             }
//                             else
//                             {
//                                 edgeTupelIterator = NULL;
//                             }
//                         }
//                     }
//                     else
//                     {
//                         edgeTupelIterator = NULL;
//                     }
// 
//                     if (!edgeTupelIterator) /* Kante nicht häufig weil sie nicht gefunden wurde in Liste der häufigen oneEdgeGraphen */
//                     {
//                         removeEdge(n->reverseEdge,n->edgeTarget);
//                         tempEdge = n->nextEdgeListElement;
//                         removeEdge(n,m);
//                         n = tempEdge;
//                         continue;
//                     }
//                     else
//                     {
//                         edgeCount++;                                      /* Es wurde eine häufige Kante gefunden, daher edgeCount++ */
//                         if (n->edgeTarget->vertexLabel != m->vertexLabel) /* Falls Kante nicht symmetrisch ist, muß auch für reverse */
//                         {                                                /* Kante edgeCount inkrementiert werden, da nur eine Richtung*/
//                             edgeCount++;                                /* berücksichtigt wird. (edgeCount muß später durch 2 dividiert */
//                         }                                                /* werden) */
//                     }
//                     n = n->nextEdgeListElement;
//                 }
//                 if (nodeDegree > maxNodeDegree)
//                 {
//                     maxNodeDegree = nodeDegree;
//                 }
//                 sortEdgeList(m);   /* die Kanten werden den Labels nach sortiert */
//                 m=m->nextNode;
//             }
//             currentGraph->edgeCount = edgeCount/2;
//             currentGraph = currentGraph -> nextGraph;
// 
// #ifdef DEBUG
//             if (edgeCount % 2 != 0)
//             {
//                 fprintf(stderr,"edgeCount Fehler\n");
//                 throw g_span_error;;
//             }
// #endif
//             edgeCount = edgeCount/2;
//             if (edgeCount>maxEdgeCount)
//             {
//                 maxEdgeCount = edgeCount;
//             }
//         }
// #ifdef DEBUG
//         printf("List of frequent one edge Graphs and their super graph lists generated\n");
// #endif
// 
//         /* Entfernen von Knoten ohne Kanten */
// 
//         previousGraph = NULL;
//         currentGraph = newDB->firstGraphInDB;
//         int nodeCount;
// 
//         while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
//         {
//             nodeCount = 0;
//             m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
//             previousNode = NULL;
// 
//             while (m)                          /*Iterieren ?ber die Knoten des Graphen */
//             {
//                 if (!m->firstEdge)
//                 {
//                     m = removeIdleNode(m, previousNode, currentGraph);            /* Entfernt den (kantenlosen) Knoten */
//                     continue;
//                 }
//                 nodeArray[nodeCount] = m;
//                 nodeCount++;
//                 previousNode = m;
//                 m=m->nextNode;
//             }
//             if (nodeCount > maxNodeCount)
//             {
//                 maxNodeCount = nodeCount;
//             }
//             currentGraph->nodeCount = nodeCount;
// 
//             if (!currentGraph->firstNode)
//             {
//                 if (previousGraph)
//                 {
//                     previousGraph->nextGraph = currentGraph->nextGraph;
//                     al.free(currentGraph);
//                     freedGraphs++;
//                     currentGraph = previousGraph->nextGraph;
//                 }
//                 else
//                 {
//                     newDB->firstGraphInDB = currentGraph->nextGraph;
//                     al.free(currentGraph);
//                     freedGraphs++;
//                     currentGraph = newDB->firstGraphInDB;
//                 }
//             }
//             else
//             {
//                 if (nodeCount > 0)
//                     qsort(nodeArray,nodeCount,sizeof(graphNodePointer),(qsort_cmp_t)nodeComp); /* Sortieren der Knoten nach Label */
//                 currentGraph->firstNode = nodeArray[0];
//                 for (k=0;k<nodeCount-1;k++)
//                 {
//                     nodeArray[k]->nextNode = nodeArray[k+1];
//                     nodeArray[k]->vertexID = -(k+1);
//                 }
//                 nodeArray[nodeCount-1]->nextNode = NULL;
//                 nodeArray[nodeCount-1]->vertexID = -nodeCount;
//                 previousGraph = currentGraph;
//                 currentGraph = currentGraph -> nextGraph;
//             }
//         }
// #ifdef DEBUG
//         printf("Processing step 3 finished\n");
//         printf("empty graphs removed: %d\n",freedGraphs);
// #endif
// 
//         currentGraph = newDB->firstGraphInDB;
//         edgeListElementPointer *edgeArray;
//         edgeArray = (edgeListElementPointer*)al.malloc(maxNodeDegree*sizeof(edgeListElementPointer));
// 
//         while (currentGraph)
//         {
//             //#ifdef SYMMETRY
//             if (useSymm)
//             {
// #ifdef CLOCK
//                 start = clock();
// #endif
//                 environmentStatistics(currentGraph);
// #ifdef CLOCK
//                 stop = clock();
//                 duration += (double) (stop-start);
// #endif
//                 computeBiconComp(currentGraph);
//             }
//             //#endif
// 
//             m = currentGraph->firstNode;
//             previousNode = NULL;
// 
//             while (m)
//             {
//                 i = 0;
//                 n = m->firstEdge;
//                 while (n)
//                 {
//                     edgeArray[i] = n;
//                     n = n->nextEdgeListElement;
//                     i++;
//                 }
//                 qsort(edgeArray,i,sizeof(edgeListElementPointer),(qsort_cmp_t)edgeComp);
//                 for (j=0;j<i-1;j++)
//                 {
//                     edgeArray[j]->nextEdgeListElement = edgeArray[j+1];
//                     edgeArray[j+1]->previousEdgeListElement = edgeArray[j];
//                 }
//                 edgeArray[i-1]->nextEdgeListElement = NULL;
//                 edgeArray[0]->previousEdgeListElement = NULL;
//                 m->firstEdge = edgeArray[0];
//                 m=m->nextNode;
//             }
//             currentGraph = currentGraph -> nextGraph;
//         }
//         al.free(edgeArray);
// #ifdef CLOCK
//         printf("Duration of Symmetry computation:  %f \n",duration/CLOCKS_PER_SEC);
// #endif
// 
//         /********* Ausgabe der Statistik der GraphDB *****************/
// 
// #ifdef DEBUG
//         printf("%d unconnected nodes removed\n", unconnected);
//         printf("Number of Graphs in DB: %d\n", graphNr);
//         printf("Iterations over DB to remove infrequent edges and vertices: %d\n", iterationsOverDB);
//         printf("Number of frequent one edge graphs:     %d\n",freqOneEdgeGraphsCount);
// 
//         edgeTupelPointer tupIt = freqOneEdgeGraphs;
//         while (tupIt)
//         {
//             printf("(%d,%d,%d,%d,%d) %d\n", tupIt->firstNodeNr, tupIt->secondNodeNr, tupIt->firstNodeValue, tupIt->edgeValue,
//                    tupIt->secondNodeValue, tupIt->occurrences);
//             tupIt = tupIt->nextEdgeTupel;
//         }
// #endif
// 
//         edgeLabelCount = edgeLabelTypes;
//         nodeLabelCount = nodeLabelTypes;
//         al.free(oneEdgeGraphHashTable);
//     }

    
    class label_mapper {
        typedef typename sdf_::atom::ele_t atom_ele_t;
        typedef typename sdf_::atom atom;
        typedef typename sdf_::bond bond;
        typedef typename sdf_::molecule molecule;
        
        std::map<int,int> m_bondtype_map;
        std::map<typename sdf_::atom_ele_t,int> m_atomtype_map;
        
        std::map<int,int> m_rev_bondtype_map;
        std::map<int,atom_ele_t> m_rev_atomtype_map;
        
        char ele_cstr[4];
    public:
        
        const char *ele_to_cstr( atom_ele_t e ) {
            assert( e.size() == 3 );
            std::copy( e.begin(), e.end(), ele_cstr );
            ele_cstr[3] = 0;
            return ele_cstr;
        }
        int canonicalize_element( const typename sdf_::atom_ele_t &ele ) {
        
        
            typename std::map< atom_ele_t, int >::iterator it = m_atomtype_map.find( ele );
            if( it == m_atomtype_map.end() ) {
                int nid = m_atomtype_map.size();
                m_atomtype_map[ele] = nid;
                m_rev_atomtype_map[nid] = ele;
                //std::cout << "atom type map: " << ele_to_cstr(ele) << " -> " << nid << "\n";
                return nid;
            } else {
            
                return it->second;
            }
            
        }
        int canonicalize_bond_type(int type) {
            std::map< int, int >::iterator it = m_bondtype_map.find(type);
            if( it == m_bondtype_map.end() ) {
                int nid = m_bondtype_map.size();
                m_bondtype_map[type] = nid;
                m_rev_bondtype_map[nid] = type;
                
                return nid;
            } else {
            
                return it->second;
                
            }
        }
        
        atom_ele_t rev_atom_type( int at ) {
         
            typename std::map< int, atom_ele_t >::iterator it = m_rev_atomtype_map.find(at);

            
            if( it == m_rev_atomtype_map.end() ) {
                throw std::runtime_error( "reverse atomtype mapping failed" );
            }
            return it->second;
        }
        
        int rev_bond_type( int bt ) {
            std::map< int, int >::iterator it = m_rev_bondtype_map.find(bt);
            
            if( it == m_rev_bondtype_map.end() ) {
             
                throw std::runtime_error( "reverse bondtype mapping failed" );
            }
            
            return it->second;
        }
        
    };
    std::vector<int> m_atom_freqsort_backmap;
    std::vector<int> m_bond_freqsort_backmap;
    label_mapper m_lm;
    
    
    graphDatabasePointer preprocessDB( std::vector<const typename sdf_::molecule*> &mols ) {
        typedef sdf_ sdf;

//         printf( "preprocessDB\n" );
    //graphDatabasePointer preprocessDB(FILE *f1) {
        //char* fileSplit = NULL;
        
        
        
        // ahhrg, it is not enough to 'canonicalize' (=make contiguous) the node/edge labels while loading the input complete sdf...
        // this caused a nasty bug, because this stuff is so damn fragile...
        
        
        
        
//         char *r;
        //fileSplit = strtok_r(filename, ".", &r);

//         if (f1==NULL)
//         {
//             fprintf(stderr,"Can't open input file\n");
//         }
//         const size_t line_len = 100;
//         char line[line_len];    /* Zum Einlesen der Zeilen des Files */

        newDB = (graphDatabasePointer)al.malloc(sizeof(graphDatabase)); /* Erzeuge leere Graphdatenbank */
#ifdef DEBUG
        if (!newDB)
        {
            fprintf(stderr,"Not enough memory for new 'graphDatabase'.\n");
            throw g_span_error;
        }
#endif
        newDB->databaseNr = 1;
        newDB->numberOfGraphsInDB = 0;
        newDB->firstGraphInDB = NULL;                                  /* GraphDB initialisiert */

        int graphNr = 0;         /* Zum Zuweisen der ID der Graphen, Bestimmen der Gesamtzahl der Graphen */

        graphPointer newGraph = NULL;
        graphPointer previousGraph = NULL;
        graphNodePointer newNode = NULL;
        graphNodePointer previousNode = NULL;
        graphNodePointer nodeIterator = NULL;
        edgeListElementPointer newEdge1;
        edgeListElementPointer newEdge2;

        int lineNumber = 0;
        int firstNodeID, secondNodeID, edgeLabel;

        
        //is.getline(line,line_len);
            
//                 if( (is.rdstate() & is.eofbit) != 0 ) {
//                     printf( "eof\n" );
//                     break;
//                     
//                 }
        for( typename std::vector<const typename sdf::molecule *>::iterator mit = mols.begin(); mit != mols.end(); ++mit )   
        {
            
            {
//                 printf( "new graph\n" );
                newGraph = (graphPointer)al.gc_malloc(sizeof(graphFromDB));  /* Erzeuge neuen Graph */
                memset( newGraph, 0, sizeof( graphFromDB ) ); // aaaarrrgghhhh! repeat after me: I will always initialize my stupid c structures.
                if (!newGraph)
                    fprintf(stderr,"Not enough memory for new 'graphFromDB'.\n");
                previousNode = NULL;
                (newDB->numberOfGraphsInDB)++;
                if (previousGraph)
                {
                    previousGraph->nextGraph = newGraph;
                    newGraph->previousGraph = previousGraph;
                }
                else                                            /* Wenn der Graph der erste in der DB ist */
                {
                    newDB->firstGraphInDB = newGraph;
                    newGraph->previousGraph = NULL;
                }

                previousGraph = newGraph;
                newGraph->graphNr = graphNr;
                newGraph->nodeMapCount = 0;
                newGraph->nextGraph = NULL;

#ifdef DEBUG
                if (graphNr != atoi(line+4))    /* Test ob die interne Zählung der Graphen und die im Graph-File übereinstimmen */
                {
                    fprintf(stderr,"Graph number problem %d %d.\n",graphNr, atoi(line+4));
                    throw g_span_error;
                }
#endif

                graphNr++;

                //while (true) /* Einlesen der Knoten des neuen Graphen */
                const typename sdf::molecule &mol = *(*mit);
                const std::vector< typename sdf::atom > &atoms = mol.m_atoms;
                int atom_id = 1;
                
                for( typename std::vector< typename sdf::atom >::const_iterator ait = atoms.begin(); ait != atoms.end(); ++ait )
                {
                    //fgets(line, 100, f1) != NULL && lineNumber++ && line[0] == 'v'
                    
//                     is.getline( line, line_len );
//                     lineNumber++;
//                     
//                     if( line[0] != 'v' ) {
//                         break;
//                         
//                     }
                    
//                     char *r;
                    lineNumber++;
                    newNode = (graphNodePointer)al.gc_malloc(sizeof(graphNode));  /* Erzeuge neuen Knoten */
//                     std::cerr << "new node: " << newNode << "\n";
                    memset( newNode, 0, sizeof( graphNode ));
                    if (!newNode)
                        fprintf(stderr,"Not enough memory for new 'graphNode'.\n");


                    
                    //strtok_r(line," ",&r);                               /* line besteht aus 3 Token: 'v', 'Knoten-Nr', 'Knoten-Label' */
                    newNode->vertexID = -(atom_id);/* vertexId soll für ungematchte Knoten negativ sein (+1 wg. 0) */
                    newNode->vertexLabel = m_lm.canonicalize_element( ait->m_ele );     /* Label des Knotens */
//                     printf( "label: %d\n", newNode->vertexLabel );
                    newNode->nextNode = NULL;
                    newNode->firstEdge = NULL;
                    newNode->smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding = -1;
                    newNode->altStartNode = 0; /* die IDs sind alle negativ */
                    nodeLabelFrequency[newNode->vertexLabel]++;  /* Häufigkeit des KnotenLabels hochsetzen */
                    
//                     printf( "new node: %p %d\n", newNode, newNode->vertexLabel );
                    atom_id++;
//                     printf( "atom %d %d\n", newNode->vertexID, newNode->vertexLabel );
                    if (previousNode)
                    {
                        previousNode->nextNode = newNode;
                    }
                    else
                    {
                        newGraph->firstNode = newNode;
                    }
                    previousNode = newNode;
                }
                nodeIterator=newGraph->firstNode;
//                  std::cerr << "node: " << nodeIterator << std::endl;
                    
                 assert( newGraph->firstNode != 0 );
                for (i=0,nodeIterator=newGraph->firstNode; nodeIterator && i<MAX_NODE_NUMBER; nodeIterator=nodeIterator->nextNode,i++)
                {
//                      std::cerr << "node: " << nodeIterator << " " << nodeIterator->nextNode << std::endl;
                    nodeArray[i] = nodeIterator;  /* Zum Erzeugen der Kanten aus IDs von Start- und Zielknoten */
                }                                 /* Index ist ID des Files, nicht die (negative) ID der GraphDB */

//                 std::cerr << "nodeiterator " << nodeIterator << std::endl;
//                 printf( "nodeArray: %d\n", i );

                const std::vector< typename sdf::bond > &bonds = mol.m_bonds;
                
                
                for( typename std::vector< typename sdf::bond >::const_iterator bit = bonds.begin(); bit != bonds.end(); ++bit )
                {
                
                    
                    {
                        newEdge1 = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));
                        newEdge2 = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));
                        if (!newEdge1 || !newEdge2)
                        {
                            fprintf(stderr,"Not enough memory for new 'edgeListElement'.\n");
                        }
//                         char *r;
//                         printf( "edge: %p %p\n", newEdge1, newEdge2 );
                    //    strtok_r(line," ",&r);  /* line besteht aus 4 Token: 'e', 'Nr des 1.Knotens', Nr des 2.Knotens','Kanten-Label' */
                        assert(bit->m_atoms.first > 0 && bit->m_atoms.second > 0 ); 
                        firstNodeID = bit->m_atoms.first - 1;     /* ID des ersten Knoten, d.h hier Index im nodeArray */
                        secondNodeID = bit->m_atoms.second - 1;    /* ID des zweiten Knoten, d.h hier Index im nodeArray */
                        
                        edgeLabel = m_lm.canonicalize_bond_type( bit->m_type );       /* Label der Kante */


//                         printf( "add edge: %d %d %d\n", firstNodeID, secondNodeID, edgeLabel );
                        newEdge1->edgeLabel = edgeLabel;
                        newEdge2->edgeLabel = edgeLabel;
                        newEdge1->edgeStartNode = nodeArray[firstNodeID];
                        newEdge2->edgeStartNode = nodeArray[secondNodeID];
                        newEdge1->edgeTarget = nodeArray[secondNodeID];
                        newEdge2->edgeTarget = nodeArray[firstNodeID];
                        
//                         printf( "%d ", nodeArray[firstNodeID] );
                        
                        //assert( secondNodeID < atoms.size() && firstNodeID < atoms.size() );
                        newEdge1->edgeTargetValue = (nodeArray[secondNodeID])->vertexLabel;
                        newEdge2->edgeTargetValue = (nodeArray[firstNodeID])->vertexLabel;

                        if ((nodeArray[firstNodeID])->firstEdge)
                            (nodeArray[firstNodeID])->firstEdge->previousEdgeListElement = newEdge1;
                        if ((nodeArray[secondNodeID])->firstEdge)
                            (nodeArray[secondNodeID])->firstEdge->previousEdgeListElement = newEdge2;

                        newEdge1->previousEdgeListElement = NULL;
                        newEdge2->previousEdgeListElement = NULL;
                        newEdge1->reverseEdge = newEdge2;
                        newEdge2->reverseEdge = newEdge1;
                        newEdge1->biconnCompNr = -1;
                        newEdge2->biconnCompNr = -1;
                        newEdge1->visited = FALSE;
                        newEdge2->visited = FALSE;
                        newEdge1->isNotEquivalent = FALSE;
                        newEdge2->isNotEquivalent = FALSE;
                        newEdge1->nextEdgeListElement = (nodeArray[firstNodeID])-> firstEdge;
                        newEdge2->nextEdgeListElement = (nodeArray[secondNodeID])-> firstEdge;

                        (nodeArray[firstNodeID])-> firstEdge = newEdge1;
                        (nodeArray[secondNodeID])-> firstEdge = newEdge2;
                        edgeLabelFrequency[edgeLabel]++;
                        
                      
                    }
                    //while (fgets(line, 100, f1) != NULL && lineNumber++ && line[0] == 'e');
                }
//                 std::cerr << "after bonds\n";
// //                 printf( "end bond\n" );
            } 

        }
        
   
        
#ifdef DEBUG
        printf("Reading of input file finished.\n");
#endif

        /* GraphDB vollständig eingelesen. Die Arrays edgeLabelFrequency und nodeLabelFrequency speichern die Häufigkeit der */
        /* verschiedenen Labels. Jetzt Entfernen von leeren Graphen, kantenlosen Knoten, nichthäufigen Kanten und nichthäufigen */
        /* Knoten samt ihren Kanten */

        /* Bestimmen der Anzahl der tatsächlich vorkommenden Kanten- und Knotenlabels*/

        int edgeLabelTypes = 0;
        int nodeLabelTypes = 0;
        int k;

       
        for (k=0; k<MAX_EDGE_TYPES && edgeLabelFrequency[k]>0; k++) /* Zweite Abbruchbedingung wg. Annahme, daß Label keine Lücken haben */
        {
            edgeLabelTypes++;
        }

        for (k=0; k<MAX_NODE_TYPES && nodeLabelFrequency[k]>0; k++)
        {
            nodeLabelTypes++;
        }
        
        
#ifdef DEBUG
        printf("Number of edge label types: %d\n",edgeLabelTypes);
        printf("Number of node label types: %d\n",nodeLabelTypes);
#endif

        /* Durchlaufen der DB zum Entfernen nichthäufiger Elemente */

        graphPointer currentGraph = NULL;  /* Iterator über die Graphen der DB */
        previousGraph = NULL;

        graphNodePointer m = NULL;
        edgeListElementPointer n = NULL;
        previousNode = NULL;
        graphNodePointer tempNode = NULL;
//         edgeListElementPointer previousEdge = NULL;
        edgeListElementPointer tempEdge = NULL;
        currentGraph = newDB->firstGraphInDB;     /*Zeigt auf den aktuell betrachteten graph der DB */
        boolean unchanged = FALSE;    /* Wird auf TRUE gesetzt , sobald ein Durchlauf durch DB ohne Änderungen erfolgte */

//         unchanged = TRUE;
        while (!unchanged)
        {
            unchanged = TRUE;
            iterationsOverDB++;                                     /* Summiert über die Anzahl der DB Durchläufe */
            previousGraph = NULL;
            currentGraph = newDB->firstGraphInDB;
            while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
            {
                if (currentGraph->firstNode == NULL)      /* Entferne leere Graphen aus DB */
                {
                    if (previousGraph)
                    {
                        previousGraph->nextGraph = currentGraph->nextGraph;
                        al.free(currentGraph);
                        freedGraphs++;
                        currentGraph = previousGraph->nextGraph;
                    }
                    else
                    {
                        newDB->firstGraphInDB = currentGraph->nextGraph;
                        al.free(currentGraph);
                        freedGraphs++;
                        currentGraph = newDB->firstGraphInDB;
                    }
                    continue;
                }
                m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
                previousNode = NULL;

                while (m)                          /*Iterieren ?ber die Knoten des Graphen */
                {
                    if (!(m->firstEdge))          /* Knoten ohne Kanten sollen entfernt werden */
                    {
                        unconnected++;                             /* Zählt Knoten, die entfernt werden, weil sie keine Kanten haben */
                        nodeLabelFrequency[m->vertexLabel]--;                            /* Aktualisiere Häufigkeit des Knotenlabels */
                        m = removeIdleNode(m, previousNode, currentGraph);                    /* Entfernt den (kantenlosen) Knoten */
                        unchanged = FALSE;                /* Weiterer Durchlauf nötig, z.B könnte Knotentyp von m nichthäufig werden */
                        continue;
                    }
                    if (nodeLabelFrequency[m->vertexLabel] < minSup)  /* Wenn Knoten nicht häufig ist, soll er gelöscht werden */
                    {
                        unchanged = FALSE;     /* Weiterer DB Durchlauf nötig, z.B könnte ein Zielknoten des Knotens kantenlos werden */

                        if (previousNode)               /* Aktualisieren der Pointer in der Knotenliste, Knoten m wird später entfernt*/
                        {
                            previousNode->nextNode = m->nextNode;
                        }
                        else
                        {
                            currentGraph->firstNode = m->nextNode;
                        }

                        n = m->firstEdge;
#ifdef DEBUG
                        if (!n)                    /* Dieses Prädikat sollte niemals erfüllt sein */
                        {
                            fprintf(stderr,"Knoten %d hat keine kanten\n", m->vertexID);
                            fprintf(stderr,"FEHLER!!!!!!!!!!\n");
                            throw g_span_error;;
                        }
#endif

                        while (n)   /* Bevor m gelöscht wird, sollen alle Kanten, die von Knoten m ausgehen gelöscht werden */
                        {
                            tempEdge = n->nextEdgeListElement;
                            edgeLabelFrequency[n->edgeLabel]--;          /* Dekrementiere Häufigkeit des Kantentyps */
                            removeEdge(n->reverseEdge,n->edgeTarget);
                            removeEdge(n,m);
                            n  = tempEdge;
                        }
                        tempNode = m;
                        (nodeLabelFrequency[m->vertexLabel])--;             /* Dekrementiere Häufigkeit des Knotentyps*/
                        m=m->nextNode;
                        al.free(tempNode);                              /* Lösche nichthäufigen Knoten m */
                    }
                    else         /* Wenn der Knoten m häufig war, iteriere über seine Kanten. Nichthäufige Kanten sollen gelöscht werden */
                    {
                        n = m->firstEdge;
                        tempEdge = NULL;
                        while (n)              /* Kanten mit Häufigkeit < minSup sollten gelöscht werden */
                        {
                            tempEdge = n->nextEdgeListElement;

                            if (edgeLabelFrequency[n->edgeLabel] < minSup)
                            {
                                unchanged = FALSE;                       /* Zielknoten könnte z.B kantenlos werden */
                                removeEdge(n->reverseEdge,n->edgeTarget);
                                removeEdge(n,m);      /* Rückrichtung braucht nicht gesucht werden. Wird vom Zielknoten aus gefunden */
                            }
                            n = tempEdge;
                        }
                        previousNode = m;
                        m = m->nextNode;
                    }
                }
                previousGraph = currentGraph;
                currentGraph = currentGraph -> nextGraph;
            }
        }
#ifdef DEBUG
        printf("Processing step 1 finished\n");
#endif

        /******** Jetzt enthält GraphDB nur noch häufige Knoten und Kanten und alle Knoten haben mind. eine Kante   ***********/

        /* Sortieren der Kanten- und Knotenlabels nach Häufigkeit, über ein int-Array, dessen Indizes die ursprünglichen Labels der */
        /* Kanten und Knoten darstellen und deren Werte die neuen Labels nach Sortierung nach Häufigkeit des Vorkommens darstellen */

        int freqSortedEdgeLabels[edgeLabelTypes];   /* Länge des Arrays ist Anzahl der tatsächlich vorkommenden Kantenlabels */
        int freqSortedNodeLabels[nodeLabelTypes];   /* Länge des Arrays ist Anzahl der tatsächlich vorkommenden Knotenlabels */

        for (k=0; k<edgeLabelTypes; k++)
        {
            freqSortedEdgeLabels[k] = k;         /* Initialisiere Array mit ursprünglichem Label */
        }
        for (k=0; k<nodeLabelTypes; k++)
        {
            freqSortedNodeLabels[k] = k;         /* Initialisiere Array mit ursprünglichem Label */
        }


        typedef int (*qsort_cmp_t)(const void *, const void *);
        
        
        edge_freq_comp_t edge_freq_comp(*this);
        node_freq_comp_t node_freq_comp(*this);
        
//         bool bla = edge_freq_comp(1,2);
        //std::sort<int *, edge_freq_comp_t>((int*)freqSortedEdgeLabels, (int*)freqSortedEdgeLabels+edgeLabelTypes, edge_freq_comp);
        std::sort((int*)freqSortedEdgeLabels, (int*)freqSortedEdgeLabels+edgeLabelTypes, edge_freq_comp);
        //qsort(freqSortedEdgeLabels,edgeLabelTypes,sizeof(int),(qsort_cmp_t)edgeFreqComp); /* Sortieren der Kantenlabels nach Häufigkeit */
        //qsort(freqSortedNodeLabels,nodeLabelTypes,sizeof(int),(qsort_cmp_t)nodeFreqComp); /* Sortieren der Knotenlabels nach Häufigkeit */
        std::sort((int*)freqSortedNodeLabels,(int*)freqSortedNodeLabels+nodeLabelTypes, node_freq_comp); /* Sortieren der Knotenlabels nach Häufigkeit */

        m_atom_freqsort_backmap.insert( m_atom_freqsort_backmap.begin(), freqSortedNodeLabels, freqSortedNodeLabels + nodeLabelTypes );
        m_bond_freqsort_backmap.insert( m_bond_freqsort_backmap.begin(), freqSortedEdgeLabels, freqSortedEdgeLabels + edgeLabelTypes );
        
        
        /* freqSortedEdgeLabels[k] entspricht: Welches ist das k-häufigste edgeLabel? */
        int freqSortedEdgeLabels2[edgeLabelTypes];   /* Länge des Arrays ist Anzahl der tatsächlich vorkommenden Kantenlabels */
        int freqSortedNodeLabels2[nodeLabelTypes];   /* Länge des Arrays ist Anzahl der tatsächlich vorkommenden Knotenlabels */

        for (k=0; k<edgeLabelTypes; k++)
        {
            freqSortedEdgeLabels2[freqSortedEdgeLabels[k]] = k;         /* Initialisiere Array mit ursprünglichem Label */
        }
        for (k=0; k<nodeLabelTypes; k++)
        {
            freqSortedNodeLabels2[freqSortedNodeLabels[k]] = k;         /* Initialisiere Array mit ursprünglichem Label */
        }

        
        /*********************** Schreibe File mit den Umnummerierungen der Knoten und Kantenlabels **************/
        /*FILE *relabeled;

        strcat(fileSplit,".txt");
        relabeled = fopen(fileSplit,"w");
        //relabeled = fopen("relabeled.txt","w");

        // freqSortedEdgeLabels2[x] entspricht: Das wieviel häufigste edgeLabel ist x?
        fprintf(relabeled, "edgeLabels\n");
        fprintf(relabeled, "fID oID\n");
        for(k=0; k<edgeLabelTypes; k++)
        {

            fprintf(relabeled,"%d    %d \n",k,freqSortedEdgeLabels[k]);
        }
        fprintf(relabeled, "\nnodeLabels\n");
        fprintf(relabeled, "fID oID\n");
        for(k=0; k<nodeLabelTypes; k++)
        {
            fprintf(relabeled,"%d %d\n",k,freqSortedNodeLabels[k]);         // Initialisiere Array mit ursprünglichem Label
        }
        fclose(relabeled);
        */
        /* Durchlaufe GraphDB zum Relabeln der Knoten */

        previousGraph = NULL;
        currentGraph = newDB->firstGraphInDB;

        while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
        {
            m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
            previousNode = NULL;
            while (m)                          /*Iterieren ?ber die Knoten des Graphen */
            {
                
//                 int lold = m->vertexLabel;
                m->vertexLabel = freqSortedNodeLabels2[m->vertexLabel];  /* Relabeln der Knoten nach Häufigkeit */
             
//                 printf( "relabel: %p %d -> %d\n", m, lold, m->vertexLabel );
                m=m->nextNode;
            }
            currentGraph = currentGraph -> nextGraph;
        }

        oneEdgeGraphHashTable = (edgeTupelPointer*)al.malloc(nodeLabelTypes*sizeof(edgeTupelPointer)); /* HashTable für oneEdgeGraphen */

        for (k=0;k<nodeLabelTypes;k++)
        {
            oneEdgeGraphHashTable[k] = NULL;
        }

        /* Durchlaufe GraphDB zum Relabeln der Kanten und Bestimmen der häufigen OneEdgeGraphs */

        previousGraph = NULL;
        currentGraph = newDB->firstGraphInDB;

        while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
        {
            m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
            previousNode = NULL;

            while (m)                          /*Iterieren ?ber die Knoten des Graphen */
            {
                n = m->firstEdge;
                while (n)   /* Iterieren über die Kanten von m */
                {
                    n->edgeLabel = freqSortedEdgeLabels2[n->edgeLabel];             /* Relabeln der Kanten nach Häufigkeit */
                    n->edgeTargetValue = n->edgeTarget->vertexLabel;
                    //printf( "n: %p %p %d\n", n, n->edgeTarget, n->edgeTargetValue );
//                     printf( "n: %p %d\n", n->edgeTarget, n->edgeTarget->vertexLabel );
//                     printf( "m: %p %p %d %d\n", m, n->edgeTarget, n->edgeTargetValue, n->edgeTarget->vertexLabel );
//                     printf( "%p %d\n", m, m->vertexLabel );
                    if (n->edgeTargetValue < m->vertexLabel)         /* Kante nicht minimal */
                    {
                        n = n->nextEdgeListElement;                 /* Gehe zur nächsten Kante */
                        continue;
                    }
                    install(n,currentGraph); /* Füge Kante in die HashTabelle der oneEdgeGraphen ein */
                    n = n->nextEdgeListElement;
                }
                m=m->nextNode;
            }
            currentGraph = currentGraph -> nextGraph;
        }

        /* Durchlaufe HashTabelle der oneEdgeGraphen, entferne seltene oneEdgeGraphen und verbinde die oneEdgeGraph-Listen */

        edgeTupelPointer edgeTupelIterator = NULL;
        edgeTupelPointer previousEdgeTupel = NULL;
        edgeTupelPointer tempEdgeTupelIterator = NULL;
        int freqOneEdgeGraphsCount = 0;

        for (k=0; k<nodeLabelTypes;k++)
        {
            edgeTupelIterator = oneEdgeGraphHashTable[k];
            while (edgeTupelIterator)
            {
                if (edgeTupelIterator->occurrences >= minSup)
                {
                    freqOneEdgeGraphsCount++;
                    if (previousEdgeTupel)
                    {
                        edgeTupelIterator->previousEdgeTupel = previousEdgeTupel;
                        previousEdgeTupel->nextEdgeTupel = edgeTupelIterator;
                    }
                    else
                    {
                        freqOneEdgeGraphs = edgeTupelIterator;    /* Erstes Element der Liste gefunden */
                    }
                    previousEdgeTupel = edgeTupelIterator;
                    edgeTupelIterator=edgeTupelIterator->nextEdgeTupel;
                }
                else
                {
                    if (previousEdgeTupel)
                    {
                        previousEdgeTupel->nextEdgeTupel = NULL;
                    }
                    if (oneEdgeGraphHashTable[k] == edgeTupelIterator)
                    {
                        oneEdgeGraphHashTable[k] = edgeTupelIterator->nextEdgeTupel;
                    }
                    tempEdgeTupelIterator = edgeTupelIterator;
                    edgeTupelIterator = edgeTupelIterator->nextEdgeTupel;
#ifdef DEBUG
                    printf("infrequent tuple: (%d,%d,%d,%d,%d) \n", tempEdgeTupelIterator->firstNodeNr, tempEdgeTupelIterator->secondNodeNr,
                           tempEdgeTupelIterator->firstNodeValue, tempEdgeTupelIterator->edgeValue, tempEdgeTupelIterator->secondNodeValue) ;
#endif
                    removeSupergraphList(tempEdgeTupelIterator);
                    al.free(tempEdgeTupelIterator);
                }
            }
        }
#ifdef DEBUG
        printf("number of frequent one edge graphs: %d\n", freqOneEdgeGraphsCount);
        printf("Processing step 2 finished\n");
#endif

        /* Entferne nichthäufige oneEdgeSubgraphen aus GraphDB, erzeuge SuperGraphListe der häufigen oneEdgeGraphen */

        previousGraph = NULL;
        currentGraph = newDB->firstGraphInDB;
        int edgeCount;
        int nodeDegree;
        int j;

        while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
        {
            m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
            previousNode = NULL;
            edgeCount = 0;

            while (m)                          /*Iterieren ?ber die Knoten des Graphen */
            {
                n = m->firstEdge;
                nodeDegree = 0;
                while (n)   /* Iterieren über die Kanten von m */
                {
                    nodeDegree++;
                    if (n->edgeTargetValue < m->vertexLabel)       /* Kante nicht minimal ->die reverse edge wird stattdessen überprüft */
                    {
                        n = n->nextEdgeListElement;                 /* Gehe zur nächsten Kante */
                        continue;
                    }

                    /* Finden der Kante in Liste der oneEdgeGraphen, bedeutet Kante ist häufig. Dann Graph in SuperGraphListe einfügen*/
                    /* Sonst nicht häufig: Entfernen der Kante aus DB.Dadurch können wieder Knoten ohne Kanten entstehen. Aber wenn  */
                    /* ein Knoten dadurch selten wird, dann ist er nach dem vollst. Durchlauf unconnected. Es genügt ein weiterer   */
                    /* Durchlauf um solche Knoten zu entfernen */

                    if (oneEdgeGraphHashTable[m->vertexLabel])
                    {
                        edgeTupelIterator = oneEdgeGraphHashTable[m->vertexLabel];
                        while (edgeTupelIterator)
                        {
                            if (edgeTupelIterator->firstNodeValue == m->vertexLabel)
                            {
                                if (edgeTupelIterator->edgeValue == n->edgeLabel)
                                {
                                    if (edgeTupelIterator->secondNodeValue== n->edgeTarget->vertexLabel)
                                    {
                                        break;
                                    }
                                }
                                edgeTupelIterator = edgeTupelIterator->nextEdgeTupel;
                            }
                            else
                            {
                                edgeTupelIterator = NULL;
                            }
                        }
                    }
                    else
                    {
                        edgeTupelIterator = NULL;
                    }

                    if (!edgeTupelIterator) /* Kante nicht häufig weil sie nicht gefunden wurde in Liste der häufigen oneEdgeGraphen */
                    {
                        removeEdge(n->reverseEdge,n->edgeTarget);
                        tempEdge = n->nextEdgeListElement;
                        removeEdge(n,m);
                        n = tempEdge;
                        continue;
                    }
                    else
                    {
                        edgeCount++;                                      /* Es wurde eine häufige Kante gefunden, daher edgeCount++ */
                        if (n->edgeTarget->vertexLabel != m->vertexLabel) /* Falls Kante nicht symmetrisch ist, muß auch für reverse */
                        {                                                /* Kante edgeCount inkrementiert werden, da nur eine Richtung*/
                            edgeCount++;                                /* berücksichtigt wird. (edgeCount muß später durch 2 dividiert */
                        }                                                /* werden) */
                    }
                    n = n->nextEdgeListElement;
                }
                if (nodeDegree > maxNodeDegree)
                {
                    maxNodeDegree = nodeDegree;
                }
                sortEdgeList(m);   /* die Kanten werden den Labels nach sortiert */
                m=m->nextNode;
            }
            currentGraph->edgeCount = edgeCount/2;
            currentGraph = currentGraph -> nextGraph;

#ifdef DEBUG
            if (edgeCount % 2 != 0)
            {
                fprintf(stderr,"edgeCount Fehler\n");
                throw g_span_error;;
            }
#endif
            edgeCount = edgeCount/2;
            if (edgeCount>maxEdgeCount)
            {
                maxEdgeCount = edgeCount;
            }
        }
#ifdef DEBUG
        printf("List of frequent one edge Graphs and their super graph lists generated\n");
#endif

        /* Entfernen von Knoten ohne Kanten */

        previousGraph = NULL;
        currentGraph = newDB->firstGraphInDB;
        int nodeCount;

        while (currentGraph)                           /* Iteriere ?ber die Graphen der DB */
        {
            nodeCount = 0;
            m = currentGraph->firstNode;       /* erster Knoten des aktuellen Graphen in Graph-DB*/
            previousNode = NULL;

            while (m)                          /*Iterieren ?ber die Knoten des Graphen */
            {
                if (!m->firstEdge)
                {
                    m = removeIdleNode(m, previousNode, currentGraph);            /* Entfernt den (kantenlosen) Knoten */
                    continue;
                }
                nodeArray[nodeCount] = m;
                nodeCount++;
                previousNode = m;
                m=m->nextNode;
            }
            if (nodeCount > maxNodeCount)
            {
                maxNodeCount = nodeCount;
            }
            currentGraph->nodeCount = nodeCount;

            if (!currentGraph->firstNode)
            {
                if (previousGraph)
                {
                    previousGraph->nextGraph = currentGraph->nextGraph;
                    al.free(currentGraph);
                    freedGraphs++;
                    currentGraph = previousGraph->nextGraph;
                }
                else
                {
                    newDB->firstGraphInDB = currentGraph->nextGraph;
                    al.free(currentGraph);
                    freedGraphs++;
                    currentGraph = newDB->firstGraphInDB;
                }
            }
            else
            {
                if (nodeCount > 0)
                    qsort(nodeArray,nodeCount,sizeof(graphNodePointer),(qsort_cmp_t)nodeComp); /* Sortieren der Knoten nach Label */
                currentGraph->firstNode = nodeArray[0];
                for (k=0;k<nodeCount-1;k++)
                {
                    nodeArray[k]->nextNode = nodeArray[k+1];
                    nodeArray[k]->vertexID = -(k+1);
                }
                nodeArray[nodeCount-1]->nextNode = NULL;
                nodeArray[nodeCount-1]->vertexID = -nodeCount;
                previousGraph = currentGraph;
                currentGraph = currentGraph -> nextGraph;
            }
        }
#ifdef DEBUG
        printf("Processing step 3 finished\n");
        printf("empty graphs removed: %d\n",freedGraphs);
#endif

        currentGraph = newDB->firstGraphInDB;
        edgeListElementPointer *edgeArray;
        edgeArray = (edgeListElementPointer*)al.malloc(maxNodeDegree*sizeof(edgeListElementPointer));

        while (currentGraph)
        {
            //#ifdef SYMMETRY
            if (useSymm)
            {
#ifdef CLOCK
                start = clock();
#endif
                environmentStatistics(currentGraph);
#ifdef CLOCK
                stop = clock();
                duration += (double) (stop-start);
#endif
                computeBiconComp(currentGraph);
            }
            //#endif

            m = currentGraph->firstNode;
            previousNode = NULL;

            while (m)
            {
                i = 0;
                n = m->firstEdge;
                while (n)
                {
                    edgeArray[i] = n;
                    n = n->nextEdgeListElement;
                    i++;
                }
                qsort(edgeArray,i,sizeof(edgeListElementPointer),(qsort_cmp_t)edgeComp);
                for (j=0;j<i-1;j++)
                {
                    edgeArray[j]->nextEdgeListElement = edgeArray[j+1];
                    edgeArray[j+1]->previousEdgeListElement = edgeArray[j];
                }
                edgeArray[i-1]->nextEdgeListElement = NULL;
                edgeArray[0]->previousEdgeListElement = NULL;
                m->firstEdge = edgeArray[0];
                m=m->nextNode;
            }
            currentGraph = currentGraph -> nextGraph;
        }
        al.free(edgeArray);
#ifdef CLOCK
        printf("Duration of Symmetry computation:  %f \n",duration/CLOCKS_PER_SEC);
#endif

        /********* Ausgabe der Statistik der GraphDB *****************/

#ifdef DEBUG
        printf("%d unconnected nodes removed\n", unconnected);
        printf("Number of Graphs in DB: %d\n", graphNr);
        printf("Iterations over DB to remove infrequent edges and vertices: %d\n", iterationsOverDB);
        printf("Number of frequent one edge graphs:     %d\n",freqOneEdgeGraphsCount);

        edgeTupelPointer tupIt = freqOneEdgeGraphs;
        while (tupIt)
        {
            printf("(%d,%d,%d,%d,%d) %d\n", tupIt->firstNodeNr, tupIt->secondNodeNr, tupIt->firstNodeValue, tupIt->edgeValue,
                   tupIt->secondNodeValue, tupIt->occurrences);
            tupIt = tupIt->nextEdgeTupel;
        }
#endif

        edgeLabelCount = edgeLabelTypes;
        nodeLabelCount = nodeLabelTypes;
        al.free(oneEdgeGraphHashTable);
        
        return 0;
    }

    /************************************************/

    void sortEdgeList(graphNodePointer node)
    {
        edgeListElementPointer edgeIterator = node->firstEdge;
        edgeListElementPointer nextEdge = NULL;
        edgeListElementPointer sortedListIterator = NULL;
        edgeListElementPointer sortedListPreviousEdge = NULL;
        edgeListElementPointer sortedListFirstEdge = NULL;
        while (edgeIterator)
        {
            nextEdge = edgeIterator->nextEdgeListElement;
            sortedListPreviousEdge = NULL;
            sortedListIterator = sortedListFirstEdge;
            while (sortedListIterator)
            {
                if (edgeIterator->edgeLabel < sortedListIterator->edgeLabel || (edgeIterator->edgeLabel == sortedListIterator->edgeLabel &&                                                        edgeIterator->edgeTarget->vertexLabel <= sortedListIterator->edgeTarget->vertexLabel))
                {
                    edgeIterator->nextEdgeListElement = sortedListIterator;
                    edgeIterator->previousEdgeListElement = sortedListIterator->previousEdgeListElement;
                    sortedListIterator->previousEdgeListElement = edgeIterator;
                    if (sortedListPreviousEdge)
                        sortedListPreviousEdge->nextEdgeListElement = edgeIterator;
                    else
                        sortedListFirstEdge = edgeIterator;
                    break;
                }
                sortedListPreviousEdge = sortedListIterator;
                sortedListIterator = sortedListIterator->nextEdgeListElement;
            }
            if (!sortedListIterator)
            {
                edgeIterator->nextEdgeListElement = NULL;

                if (sortedListPreviousEdge)
                {
                    sortedListPreviousEdge->nextEdgeListElement = edgeIterator;
                    edgeIterator->previousEdgeListElement = sortedListPreviousEdge;
                }
                else
                {
                    edgeIterator->previousEdgeListElement = NULL;
                    sortedListFirstEdge = edgeIterator;
                }
            }
            edgeIterator = nextEdge;
        }
        node->firstEdge = sortedListFirstEdge;
    }

    void removeEdge(edgeListElementPointer edge, graphNodePointer node)
    {
        if (edge->previousEdgeListElement)
        {
            edge->previousEdgeListElement->nextEdgeListElement = edge->nextEdgeListElement;
        }
        else
        {
            node->firstEdge = edge->nextEdgeListElement;
        }
        if (edge->nextEdgeListElement)
        {
            edge->nextEdgeListElement->previousEdgeListElement = edge->previousEdgeListElement;
        }
        al.free(edge);
    }

    graphNodePointer removeIdleNode(graphNodePointer node, graphNodePointer previousNode, graphPointer currentGraph)
    {
        graphNodePointer tempNode;
        if (previousNode)
        {
            previousNode->nextNode = node->nextNode;
        }
        else
        {
            currentGraph->firstNode = node->nextNode;
        }
        tempNode = node;
        node = node->nextNode;
        al.free(tempNode);
        return node;
    }

//     static int edgeFreqComp(int *index1, int *index2)
//     {
//         //#ifdef ASCFREQ
//         if (useAscFreqOrder)
//         {
//             if (edgeLabelFrequency[*index1] < edgeLabelFrequency[*index2]) return -1;
//             if (edgeLabelFrequency[*index1] > edgeLabelFrequency[*index2]) return 1;
//         }
//         //#else
//         else
//         {
//             if (edgeLabelFrequency[*index1] < edgeLabelFrequency[*index2]) return 1;
//             if (edgeLabelFrequency[*index1] > edgeLabelFrequency[*index2]) return -1;
//         }
//         //#endif
//         return 0;
//     }
// 
//     static int nodeFreqComp(int *index1, int *index2)
//     {
//         //#ifdef ASCFREQ
//         if (useAscFreqOrder)
//         {
//             if (nodeLabelFrequency[*index1] < nodeLabelFrequency[*index2]) return -1;
//             if (nodeLabelFrequency[*index1] > nodeLabelFrequency[*index2]) return 1;
//         }
//         //#else
//         else
//         {
//             if (nodeLabelFrequency[*index1] < nodeLabelFrequency[*index2]) return 1;
//             if (nodeLabelFrequency[*index1] > nodeLabelFrequency[*index2]) return -1;
//         }
//         //#endif
//         return 0;
//     }

    static int nodeComp(graphNodePointer *index1, graphNodePointer *index2)
    {
        if ((*index1)->vertexLabel < (*index2)->vertexLabel) return -1;
        if ((*index1)->vertexLabel > (*index2)->vertexLabel) return 1;
        return 0;
    }

    static int edgeComp(edgeListElementPointer *edge1, edgeListElementPointer *edge2)
    {
        if ((*edge1)->edgeLabel < (*edge2)->edgeLabel) return -1;
        if ((*edge1)->edgeLabel > (*edge2)->edgeLabel) return 1;
        if ((*edge1)->edgeTarget->vertexLabel < (*edge2)->edgeTarget->vertexLabel) return -1;
        if ((*edge1)->edgeTarget->vertexLabel > (*edge2)->edgeTarget->vertexLabel) return 1;
        if ((*edge1)->edgeTarget->altStartNode > (*edge2)->edgeTarget->altStartNode) return -1;
        if ((*edge1)->edgeTarget->altStartNode < (*edge2)->edgeTarget->altStartNode) return 1;
        return 0;
    }

    unsigned hash(edgeListElementPointer edge)
    {
        unsigned hashval;
        hashval = edge->edgeStartNode->vertexLabel;  /* HashFunktion gibt Label des Startknotens zurück */
        return hashval;
    }

    edgeTupelPointer lookup(edgeListElementPointer edge)
    {
        edgeTupelPointer iterator;

        for (iterator = oneEdgeGraphHashTable[edge->edgeStartNode->vertexLabel]; iterator != NULL; iterator = iterator->nextEdgeTupel)
        {
            if ((edge->edgeTarget->vertexLabel == iterator->secondNodeValue) && (edge->edgeLabel == iterator->edgeValue))
            {
                return iterator;
            }
        }
        return NULL;
    }

    edgeTupelPointer install(edgeListElementPointer edge, graphPointer currentGraph)
    {
        edgeTupelPointer oneEdgeGraph;
        unsigned hashval;
        oneEdgeGraph = lookup(edge);
        if (!oneEdgeGraph)                         /* Graph ist noch nicht im Hash*/
        {
            hashval = hash(edge);
            edgeTupelPointer tupelIterator = oneEdgeGraphHashTable[hashval];
            edgeTupelPointer previousTupel = NULL;
            while (tupelIterator)
            {
                /* Bestimme Einfügeposition des neuen oneEdgeGraphen in Liste */
                if (tupelIterator->edgeValue < edge->edgeLabel) /* oneEdgeGraph muß weiter rechts in Liste eingefügt werden */
                {
                    previousTupel = tupelIterator;
                    tupelIterator = tupelIterator->nextEdgeTupel;
                    continue;
                }
                if (tupelIterator->edgeValue > edge->edgeLabel) /* oneEdgeGraph muß vor tupelIterator eingefügt werden */
                {
                    break;
                }
                if (tupelIterator->edgeValue == edge->edgeLabel)
                {
                    if (tupelIterator->secondNodeValue < edge->edgeTarget->vertexLabel)
                    {
                        previousTupel = tupelIterator;
                        tupelIterator = tupelIterator->nextEdgeTupel;
                        continue;
                    }
                    if (tupelIterator->secondNodeValue > edge->edgeTarget->vertexLabel)
                    {
                        break;
                    }
                    if (tupelIterator->secondNodeValue == edge->edgeTarget->vertexLabel)
                    {
#ifdef DEBUG
                        fprintf(stderr, "Fehler in der Liste der häufigen oneEdgeGraphs Liste\n");
                        throw g_span_error;;
#endif
                    }
                }
            }
            /* Erzeugen des neuen Graphen und Einfügen in Liste */
            oneEdgeGraph = (edgeTupelPointer) al.gc_malloc(sizeof(edgeTupel));
            oneEdgeGraph->firstNodeNr = 0;
            oneEdgeGraph->secondNodeNr = 1;
            oneEdgeGraph->firstNodeValue = edge->edgeStartNode->vertexLabel;
            oneEdgeGraph->edgeValue = edge->edgeLabel;
            oneEdgeGraph->secondNodeValue = edge->edgeTarget->vertexLabel;
            oneEdgeGraph->occurrences = 1;
            oneEdgeGraph->lengthOfRightestPath = 1;
            oneEdgeGraph->longestPathSize = 1;
            oneEdgeGraph->nextEdgeTupel = tupelIterator;
            oneEdgeGraph->firstChildEdgeTupel = NULL;
            oneEdgeGraph->parentEdgeTupel = NULL;
            if (tupelIterator)
            {
                oneEdgeGraph->nextEdgeTupel = tupelIterator;
                tupelIterator->previousEdgeTupel = oneEdgeGraph;
            }
            else
            {
                oneEdgeGraph->nextEdgeTupel = NULL;
            }
            if (previousTupel)
            {
                oneEdgeGraph->previousEdgeTupel = previousTupel;
                previousTupel->nextEdgeTupel = oneEdgeGraph;
            }
            else
            {
                oneEdgeGraph->previousEdgeTupel = NULL;
                oneEdgeGraphHashTable[hashval] = oneEdgeGraph;
            }

            superGraphListPointer currentSuperGraphList;
            currentSuperGraphList = (superGraphListPointer)al.gc_malloc(sizeof(superGraphList));
            currentSuperGraphList->firstSuperGraph = NULL;
            currentSuperGraphList->lastSuperGraph = NULL;
            currentSuperGraphList->size = 0;
            insertInSuperGraphList(currentSuperGraphList, currentGraph);

            oneEdgeGraph->superGraphList = currentSuperGraphList; /* SuperGraphListe ist noch leer, vorerst wird nur occurrences verwendet */
            oneEdgeGraph->firstOccOfStartNode = 0;
        }
        else
        {
#ifdef DEBUG
            if (oneEdgeGraph->superGraphList->lastSuperGraph->superGraphAdressInDB->graphNr > currentGraph->graphNr)
            {
                (oneEdgeGraph->occurrences)++;
                printf("Fehler in Supergraphliste\n");
                throw g_span_error;;
            }
#endif

            if (oneEdgeGraph->superGraphList->lastSuperGraph->superGraphAdressInDB->graphNr < currentGraph->graphNr)
            {
                (oneEdgeGraph->occurrences)++;
                insertInSuperGraphList(oneEdgeGraph->superGraphList, currentGraph);
            }
            else if (oneEdgeGraph->superGraphList->lastSuperGraph->superGraphAdressInDB->graphNr == currentGraph->graphNr)
            {
                oneEdgeGraph->superGraphList->lastSuperGraph->occ++;
            }
            return NULL;
        }
        return oneEdgeGraph;
    }



/////////////////////////////////////////////////////////////
// biconn.cpp
////////////////////////////////////////////////////////////

#define MIN2(x,y) ((x)<(y) ? (x) : (y))


// void biconn(graphNodePointer currentNode, graphNodePointer precedessor);

// extern int maxNodeDegree;

// int *dfsNum;
// int *low;
// int num;
// int biCompCount;
// edgeListElementPointer * edgeStack;
// int edgeStackTop;
    int computeBiconComp(graphPointer graph)
    {
        num = 0;
        biCompCount = 0;                     /* Counter für die Anzahl der biconnected components */
        int nodeCount = graph->nodeCount;

        dfsNum = (int*)al.malloc(nodeCount*sizeof(int));     /* Array, das zu jedem Knoten des Graphen die dfs Nummer berechnet */
        low = (int*)al.malloc(nodeCount*sizeof(int));        /* niedrigste dfs Nummer, die von einem Knoten in DFS Suche erreicht werden kann */

        edgeStack = NULL;
        int edgeStackSize = graph->edgeCount;
        edgeStack = (edgeListElementPointer*)al.malloc(edgeStackSize*sizeof(edgeListElementPointer));  /* Speichert die besuchten Kanten */
        edgeStackTop = -1;

        int i;
        for (i=0;i<nodeCount;i++)
        {
            dfsNum[i] = -1;
            low[i] = -1;
        }

        graphNodePointer nodeIt = graph->firstNode;
        while (nodeIt)                              /* Iteriere über die Knoten des Graphen */
        {
            if (dfsNum[-1-nodeIt->vertexID] == -1) /* wurden sie noch nicht in dfs Suche aufgesucht, beginne Suche von diesem Knoten aus */
            {
                biconn(nodeIt, NULL);
            }
            nodeIt = nodeIt ->nextNode;
        }
        al.free(dfsNum);
        al.free(low);
        al.free(edgeStack);
        return biCompCount;
    }

    void biconn(graphNodePointer currentNode, graphNodePointer precedessor)
    {
        int targetID;
        int nodeID = -1-currentNode->vertexID;
        dfsNum[nodeID] = num;
        low[nodeID] = num++;
        edgeListElementPointer edgeIt;
        for (edgeIt=currentNode->firstEdge; edgeIt; edgeIt=edgeIt->nextEdgeListElement)
        {
            targetID = -1-edgeIt->edgeTarget->vertexID;
            if (edgeIt->edgeTarget != precedessor && dfsNum[targetID] < dfsNum[nodeID])
            {
                edgeStack[++edgeStackTop] = edgeIt;
                if (dfsNum[targetID] < 0)
                {
                    biconn(edgeIt->edgeTarget,currentNode);
                    low[nodeID] = MIN2(low[nodeID],low[targetID]);
                    if (low[targetID] >= dfsNum[nodeID])
                    {
                        do
                        {
                            if (edgeStackTop < 0)
                                break;
                            edgeStack[edgeStackTop]->biconnCompNr = biCompCount;
                            edgeStack[edgeStackTop]->reverseEdge->biconnCompNr = biCompCount;
                        } while (edgeStack[edgeStackTop--] != edgeIt);
                        biCompCount++;
                    }
                }
                else if ((edgeIt->edgeTarget != precedessor))
                {
                    low[nodeID]= MIN2(low[nodeID],dfsNum[targetID]);
                }
            }
        }
    }






/////////////////////////////////////////////////////////////
// computeSymm.cpp
/////////////////////////////////////////////////////////////

// void extendEnvironment(edgeTupelPointer lastBfsTupel, graphNodePointer *kDistantNodes, int listSize, int *distanceLevelSize, int distance);
// int permutateEdgeList(graphNodePointer *nodePermutation, int startIndex, int stopIndex, edgeTupelPointer currentTupel, int depth);
// void removeEdgeFromEdgeList(edgeListElementPointer edge);
// void reinsertEdgeInEdgeList(edgeListElementPointer edge);
// int* computeBfsCode(graphPointer currentGraph, graphNodePointer currentStartNode);

// void extendEnvironment2(edgeTupelPointer lastBfsTupel, graphNodePointer *kDistantNodes, int listSize, int *distanceLevelSize, int distance);
// int permutateEdgeList2(graphNodePointer *nodePermutation, int startIndex, int stopIndex, edgeTupelPointer currentTupel, int depth);
// int* computeBfsCode2(graphPointer currentGraph, graphNodePointer currentStartNode);


// int matchedNodeCount = 0;
// edgeTupelPointer bfsCode = NULL;
// int *originalNodeIDs;
//
//
//
// int ** commonEnvSize;
// int maxCommEnvSize;
// int ** distanceLevelSize;
// int nodeCount;
//
// edgeListElementPointer firstEdgeIt;
// edgeListElementPointer secondEdgeIt;
// edgeTupelPointer secondSiblingEdge;
// edgeListElementPointer previousEdge = NULL;
// edgeListElementPointer nextEdge = NULL;
// int viererkreisCount = 0;
// int mapCount = 0;

    void environmentStatistics(graphPointer currentGraph)
    {
        mapCount = 0;
        originalNodeIDs = (int*)al.malloc((maxNodeCount)*sizeof(int));
        nodeCount = currentGraph->nodeCount;
        edgeTupelPointer bfsCodes[nodeCount];
        distanceLevelSize = (int**)al.malloc(nodeCount*sizeof(int*));
        int i,j;
        for (i=0;i<currentGraph->nodeCount;i++)
        {
            distanceLevelSize[i] = NULL;
        }
        graphNodePointer currentStartNode = currentGraph->firstNode;

        while (currentStartNode)   /* Erzeuge für jeden Knoten des Graphen einen BFS Code mit ihm als Startknoten */
        {
            bfsCode = NULL;
            distanceLevelSize[-1-currentStartNode->vertexID] = computeBfsCode(currentGraph, currentStartNode);
            bfsCodes[-1-currentStartNode->vertexID] = bfsCode;
            currentStartNode = currentStartNode->nextNode;
        }

        graphNodePointer dfsCodeStartNode;
        graphNodePointer permStartNode;
        graphNodePointer nodePermutation[currentGraph->nodeCount];
        for (i=0;i<currentGraph->nodeCount;i++)
        {
            nodePermutation[i] = NULL;
        }

        commonEnvSize = (int**)al.malloc(nodeCount*sizeof(int*));
        for (i=0;i<nodeCount;i++)
        {
            commonEnvSize[i] = (int*)al.malloc(nodeCount*sizeof(int));
        }
        for (i=0;i<nodeCount;i++)
        {
            for (j=0;j<nodeCount;j++)
            {
                commonEnvSize[i][j] = -1;
            }
        }

        /**************************************/
        int commonNeighbors = 0;
        int returnValue;
        /*************************************/

        for (dfsCodeStartNode = currentGraph->firstNode;dfsCodeStartNode;dfsCodeStartNode=dfsCodeStartNode->nextNode)
        {
            for (permStartNode=dfsCodeStartNode->nextNode; permStartNode; permStartNode=permStartNode->nextNode)
            {
                maxCommEnvSize = -1;
                if (permStartNode->vertexLabel == dfsCodeStartNode->vertexLabel)
                {
                    if (mapCount > 0)
                    {
                        for (i=0;i<-1-dfsCodeStartNode->vertexID;i++)
                        {
                            if (commonEnvSize[i][-1-dfsCodeStartNode->vertexID] != commonEnvSize[i][-1-permStartNode->vertexID])
                            {
                                maxCommEnvSize = 0;
                                break;
                            }
                            else
                            {
                                if (commonEnvSize[i][-1-dfsCodeStartNode->vertexID] == maxNodeCount)
                                {
                                    maxCommEnvSize = maxNodeCount;
                                    break;
                                }
                            }
                        }
                    }
                    if (maxCommEnvSize < 0)
                    {
                        maxCommEnvSize = 0;
                        nodePermutation[0] = permStartNode;
                        originalNodeIDs[0] = permStartNode->vertexID;
                        permStartNode->vertexID = 0;
                        returnValue = permutateEdgeList(nodePermutation, 0, 0, bfsCodes[-1-dfsCodeStartNode->vertexID], 1);
#ifdef DEBUG
                        if (returnValue != 0)
                        {
                            fprintf(stderr,"bfs code error!\n");
                            throw g_span_error;;
                        }
#endif
                        permStartNode->vertexID = originalNodeIDs[0];
                    }
                }
                commonEnvSize[-1-dfsCodeStartNode->vertexID][-1-permStartNode->vertexID] = maxCommEnvSize;

                /********************************************************/

                if (maxCommEnvSize == maxNodeCount) /* Wenn die Knoten aufeinander abgebildet werden können */
                {
                    mapCount++;
                    commonNeighbors = 0;
                    for (firstEdgeIt = dfsCodeStartNode->firstEdge; firstEdgeIt; firstEdgeIt = firstEdgeIt->nextEdgeListElement)
                    {
                        for (secondEdgeIt = permStartNode->firstEdge; secondEdgeIt; secondEdgeIt = secondEdgeIt->nextEdgeListElement)
                        {
                            if (firstEdgeIt->edgeTarget->vertexID == secondEdgeIt->edgeTarget->vertexID)
                            {
                                if (firstEdgeIt->edgeLabel == secondEdgeIt->edgeLabel)
                                {
                                    commonNeighbors++;
                                }
                            }
                        }
                    }
                    if (commonNeighbors > 1)
                    {
                        for (firstEdgeIt = dfsCodeStartNode->firstEdge; firstEdgeIt; firstEdgeIt = firstEdgeIt->nextEdgeListElement)
                        {
                            for (secondEdgeIt = permStartNode->firstEdge; secondEdgeIt; secondEdgeIt = secondEdgeIt->nextEdgeListElement)
                            {
                                if (firstEdgeIt->edgeTarget->vertexID == secondEdgeIt->edgeTarget->vertexID)
                                {
                                    if (firstEdgeIt->edgeLabel == secondEdgeIt->edgeLabel)
                                    {
                                        previousEdge = NULL;
                                        nextEdge = NULL;
                                        if (firstEdgeIt != dfsCodeStartNode->firstEdge)
                                        {
                                            previousEdge = firstEdgeIt->previousEdgeListElement;
                                            nextEdge = firstEdgeIt->nextEdgeListElement;

                                            if (firstEdgeIt->nextEdgeListElement)
                                                firstEdgeIt->nextEdgeListElement->previousEdgeListElement = firstEdgeIt->previousEdgeListElement;
                                            firstEdgeIt->previousEdgeListElement->nextEdgeListElement = firstEdgeIt->nextEdgeListElement;
                                            firstEdgeIt->previousEdgeListElement = NULL;

                                            dfsCodeStartNode->firstEdge->previousEdgeListElement = firstEdgeIt;
                                            firstEdgeIt->nextEdgeListElement = dfsCodeStartNode->firstEdge;
                                            dfsCodeStartNode->firstEdge = firstEdgeIt;
                                            edgeListElementPointer testIt = firstEdgeIt;
                                            while (testIt)
                                            {
                                                testIt= testIt->nextEdgeListElement;
                                            }
                                        }
                                        computeBfsCode2(currentGraph, dfsCodeStartNode);
                                        nodePermutation[0] = permStartNode;
                                        originalNodeIDs[0] = permStartNode->vertexID;
                                        permStartNode->vertexID = 0;
                                        maxCommEnvSize = 0;
                                        returnValue = permutateEdgeList2(nodePermutation, 0, 0, bfsCode, 1);
#ifdef DEBUG
                                        if (returnValue != 0)
                                        {
                                            fprintf(stderr,"bfs code error!\n");
                                            throw g_span_error;;
                                        }
#endif
                                        permStartNode->vertexID = originalNodeIDs[0];
                                        if (previousEdge)
                                        {
                                            firstEdgeIt->nextEdgeListElement->previousEdgeListElement = NULL;
                                            dfsCodeStartNode->firstEdge = firstEdgeIt->nextEdgeListElement;
                                            previousEdge->nextEdgeListElement = firstEdgeIt;
                                            firstEdgeIt->previousEdgeListElement = previousEdge;
                                            if (nextEdge)
                                                nextEdge->previousEdgeListElement = firstEdgeIt;
                                            firstEdgeIt->nextEdgeListElement = nextEdge;
                                        }
                                        if (maxCommEnvSize != maxNodeCount)     /* zwei Kanten (u,v_1), (u,v_2) sind equivalent solange u und */
                                        {                                         /* v_1 auf v_2 abgebildet werden kann und umgekehrt und */
                                            firstEdgeIt->isNotEquivalent = TRUE;  /* es sich bei den Kanten um keine der Ausnahmen handelt, */
                                            secondEdgeIt->isNotEquivalent = TRUE; /* die mit isNotEquivalent = TRUE gekennzeichnet sind */
                                        }
#ifdef DEBUG
                                        if (maxCommEnvSize != maxNodeCount)
                                            printf("Fehler in %d\n",currentGraph->graphNr);
#endif
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        int smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding[nodeCount];
        int altStartNode[nodeCount];

        for (i=0;i<nodeCount;i++)
        {
            smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding[i] = 0;
            altStartNode[i] = -(i+1);
        }

        for (i=0;i<nodeCount;i++)
        {
            for (j=i+1;j<nodeCount;j++)
            {
                if (smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding[j] < commonEnvSize[i][j]+1)
                {
                    smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding[j] = commonEnvSize[i][j]+1;
                    if (smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding[j]>maxNodeCount)
                        altStartNode[j] = -(i+1);
                }
            }
        }
        currentStartNode = currentGraph->firstNode;
        j = 0;

        while (currentStartNode)
        {
            currentStartNode->smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding =                                                                                                  smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding[j];
            currentStartNode->altStartNode = altStartNode[j];
            j++;
            currentStartNode = currentStartNode->nextNode;
        }

        for (i=0;i<nodeCount;i++)
        {
            al.free(commonEnvSize[i]);
        }
        al.free(commonEnvSize);
        al.free(originalNodeIDs);
        for (i=0;i<nodeCount;i++)
        {
            al.free(distanceLevelSize[i]);
        }
        al.free(distanceLevelSize);
        edgeTupelPointer bfsIt;
        edgeTupelPointer bfsFree;
        for (i=0;i<nodeCount;i++)
        {
            bfsIt = bfsCodes[i];
            while (bfsIt)
            {
                bfsFree = bfsIt;
                bfsIt = bfsIt->nextEdgeTupel;
                al.free(bfsFree);
            }
        }
        currentGraph->nodeMapCount = mapCount;
    }

    /***************************************************************************************************/
    int permutateEdgeList2(graphNodePointer *nodePermutation, int startIndex, int stopIndex, edgeTupelPointer currentTupel, int depth)
    {
        edgeListElementPointer currentEdge = nodePermutation[startIndex]->firstEdge;
        int returnValue = -1;
        int originalNodeID;

        if (!currentTupel)  /* bfs code vollständig embedded */
        {
            if (currentEdge) /* Es gibt in der Tiefe depth mehr Kanten als im Vergleichs-bfs-code, mit dem aktuellen Startknoten kann */
            {                                        /* maximal ein Embedding der Tiefe depth-1 gefunden werden */
                return 0;
            }
            else
            {
                if (startIndex < stopIndex) /* und es noch andere Knoten im gleichen Abstand zum Zentrum gibt */
                {
                    return permutateEdgeList2(nodePermutation, startIndex+1, stopIndex, currentTupel, depth);
                }
                if (startIndex == stopIndex) /* Wenn man keine Kinder der Knoten der Tiefe depth-1 mehr gefunden hat */
                {
                    if (depth > maxCommEnvSize)   /* Ist die Umgebung bis zur Tiefe depth gleich */
                        maxCommEnvSize = depth;
                    if (depth == nodeCount-1)
                        maxCommEnvSize = maxNodeCount;
                    else if (distanceLevelSize[-1-originalNodeIDs[0]][depth+1]==0) /* Dann sind die beiden Knoten isomorph. Der 2. Knoten */
                        maxCommEnvSize = maxNodeCount;               /*  muß niemals als Startknoten für ein Embedding verwendet werden */
                    return 0;                     /* eine größere embedding Tiefe kann nicht gefunden werden, da die maximale Tiefe */
                }                                  /* des bfsCodes erreicht wurde */
            }
        }

        if (!currentEdge) /* Eine vollständige Permutation der Kinder eines Knotens wurde gefunden */
        {
            if (startIndex < stopIndex) /* und es noch andere Knoten im gleichen Abstand zum Zentrum gibt */
            {
                return permutateEdgeList2(nodePermutation, startIndex+1, stopIndex, currentTupel, depth);
            }
            else
            {
                if (depth > maxCommEnvSize)   /* Updaten der Größe der gemeinsamen Umgebung */
                    maxCommEnvSize = depth;
                stopIndex = stopIndex + distanceLevelSize[-1-originalNodeIDs[0]][depth];

                if (nodePermutation[startIndex+1]) /* Wenn es noch weitere Knoten in der Queue gibt (im Abstand k+1) */
                {
                    return permutateEdgeList2(nodePermutation, startIndex+1, stopIndex, currentTupel, depth+1);
                }
                else /* es gibt keine Knoten mehr, die einen größeren Abstand zum Zentrum haben. Die beiden Startpunkte werden in einem */
                {    /* Automorphismus aufeinander Abgebildet */
                    return 0;
                }
            }
        }

        currentEdge = nodePermutation[startIndex]->firstEdge;
        while (currentEdge) /* Teste, ob die aktuelle Kante noch mit dem BFS Code übereinstimmt ...*/
        {
#ifdef DEBUG
            if (!currentTupel)
                printf("leeres tupel\n");
#endif

            if (currentTupel->firstNodeNr < currentTupel->secondNodeNr) /* Tupel aus BFS Code ist nicht umgedreht (NNB) */
            {
                if (currentTupel->firstNodeNr < currentEdge->edgeStartNode->vertexID)
                {
                    /* Gehe zurück zu dem Punkt, wo der Knoten mit der Nr. currentTupel->firstNodeNr gematcht wurde*/
                    return currentTupel->firstNodeNr;
                }
                if (currentTupel->firstNodeNr > currentEdge->edgeStartNode->vertexID)
                {
                    /* Gehe zurück zu dem Punkt, wo der Knoten mit der Nr. currentEdge->edgeStartNode->vertexID gematcht wurde*/
                    return currentEdge->edgeStartNode->vertexID;
                }
                if (currentEdge->edgeTarget->vertexID < 0)
                {
#ifdef DEBUG
                    if (currentTupel->firstNodeValue != currentEdge->edgeStartNode->vertexLabel)
                    {
                        fprintf(stderr,"Matching error1\n");
                        throw g_span_error;;
                    }
#endif
                    if (currentTupel->edgeValue==currentEdge->edgeLabel)
                    {
                        if (currentTupel->secondNodeValue==currentEdge->edgeTarget->vertexLabel) /* Kante stimmt mit BFS Tupel überein */
                        {
                            /* Teste, ob die beiden Kanten aufeinanfer gematcht werden */
                            if (currentTupel == bfsCode)
                            {
                                if (currentEdge != secondEdgeIt)
                                {
                                    currentEdge = currentEdge->nextEdgeListElement;
                                    continue;
                                }
                            }
                            else
                            {
                                if (currentEdge == secondEdgeIt)
                                {
                                    currentEdge = currentEdge->nextEdgeListElement;
                                    continue;
                                }
                            }
                            if (currentTupel == secondSiblingEdge)
                            {
                                if (currentEdge != firstEdgeIt->reverseEdge)
                                {
                                    currentEdge = currentEdge->nextEdgeListElement;
                                    continue;
                                }
                            }
                            else
                            {
                                if (currentEdge == firstEdgeIt->reverseEdge)
                                {
                                    currentEdge = currentEdge->nextEdgeListElement;
                                    continue;
                                }
                            }
                            /********************/
                            originalNodeID = currentEdge->edgeTarget->vertexID;
                            currentEdge->edgeTarget->vertexID = currentTupel->secondNodeNr;
                            removeEdgeFromEdgeList(currentEdge->reverseEdge);
                            removeEdgeFromEdgeList(currentEdge);

                            nodePermutation[currentTupel->secondNodeNr] = currentEdge->edgeTarget;
                            returnValue = permutateEdgeList2(nodePermutation, startIndex, stopIndex, currentTupel->nextEdgeTupel, depth);
                            reinsertEdgeInEdgeList(currentEdge->reverseEdge);
                            reinsertEdgeInEdgeList(currentEdge);
                            nodePermutation[currentTupel->secondNodeNr] = NULL;

                            if (returnValue != currentEdge->edgeTarget->vertexID)
                            {
                                currentEdge->edgeTarget->vertexID = originalNodeID;
                                return returnValue;
                            }
                            currentEdge->edgeTarget->vertexID = originalNodeID;
                        }
                    }
                }
            }
            else /* BFS Tupel ist umgedreht, OCC oder ECC */
            {
                if (currentTupel->secondNodeNr < currentEdge->edgeStartNode->vertexID)
                {
                    /* Gehe zurück zu dem Punkt, wo der Knoten mit der Nr. currentTupel->secondNodeNr erstmals gematcht wurde*/
                    return currentTupel->secondNodeNr;
                }
                if (currentTupel->secondNodeNr > currentEdge->edgeStartNode->vertexID)
                {
                    /* Gehe zurück zu dem Punkt, wo der Knoten mit der Nr. currentEdge->edgeStartNode->vertexID gematcht wurde*/
                    return currentEdge->edgeStartNode->vertexID;
                }
                if (currentTupel->firstNodeNr == currentEdge->edgeTarget->vertexID)
                {
#ifdef DEBUG
                    if (currentTupel->secondNodeValue != currentEdge->edgeStartNode->vertexLabel)
                    {
                        fprintf(stderr,"Matching error2\n");
                        throw g_span_error;;
                    }
#endif
                    if (currentTupel->edgeValue==currentEdge->edgeLabel)
                    {
                        if (currentTupel->firstNodeValue == currentEdge->edgeTarget->vertexLabel) /* Kante stimmt mit BFS Tupel überein */
                        {
                            removeEdgeFromEdgeList(currentEdge->reverseEdge);
                            removeEdgeFromEdgeList(currentEdge);
                            returnValue = permutateEdgeList2(nodePermutation, startIndex, stopIndex, currentTupel->nextEdgeTupel, depth);
                            reinsertEdgeInEdgeList(currentEdge->reverseEdge);
                            reinsertEdgeInEdgeList(currentEdge);
                            return returnValue;  /* Kante ist keine NNB, daher kann der gesuchte Knoten nicht erstmals hier auftauchen */
                        }
                    }
                }
            }
            currentEdge = currentEdge->nextEdgeListElement;
        }

        if (returnValue>0)
            return returnValue-1;
        else
            return currentTupel->firstNodeNr;
    }
    /***********************************************************************************************************/

    int permutateEdgeList(graphNodePointer *nodePermutation, int startIndex, int stopIndex, edgeTupelPointer currentTupel, int depth)
    {
        check_timeout();
        edgeListElementPointer currentEdge = nodePermutation[startIndex]->firstEdge;
        int returnValue = -1;
        int originalNodeID;

        if (!currentTupel)  /* bfs code vollständig embedded */
        {
            if (currentEdge) /* Es gibt in der Tiefe depth mehr Kanten als im Vergleichs-bfs-code, mit dem aktuellen Startknoten kann */
            {                                        /* maximal ein Embedding der Tiefe depth-1 gefunden werden */
                return 0;
            }
            else
            {
                if (startIndex < stopIndex) /* und es noch andere Knoten im gleichen Abstand zum Zentrum gibt */
                {
                    return permutateEdgeList(nodePermutation, startIndex+1, stopIndex, currentTupel, depth);
                }
                if (startIndex == stopIndex) /* Wenn man keine Kinder der Knoten der Tiefe depth-1 mehr gefunden hat */
                {
                    if (depth > maxCommEnvSize)   /* Ist die Umgebung bis zur Tiefe depth gleich */
                        maxCommEnvSize = depth;
                    if (depth == nodeCount-1)
                        maxCommEnvSize = maxNodeCount;
                    else if (distanceLevelSize[-1-originalNodeIDs[0]][depth+1]==0) /* Dann sind die beiden Knoten isomorph. Der 2. Knoten */
                        maxCommEnvSize = maxNodeCount;               /*  muß niemals als Startknoten für ein Embedding verwendet werden */
                    return 0;                     /* eine größere embedding Tiefe kann nicht gefunden werden, da die maximale Tiefe */
                }                                  /* des bfsCodes erreicht wurde */
            }
        }

        if (!currentEdge) /* Eine vollständige Permutation der Kinder eines Knotens wurde gefunden */
        {
            if (startIndex < stopIndex) /* und es noch andere Knoten im gleichen Abstand zum Zentrum gibt */
            {
                return permutateEdgeList(nodePermutation, startIndex+1, stopIndex, currentTupel, depth);
            }
            else
            {
                if (depth > maxCommEnvSize)   /* Updaten der Größe der gemeinsamen Umgebung */
                    maxCommEnvSize = depth;
                stopIndex = stopIndex + distanceLevelSize[-1-originalNodeIDs[0]][depth];

                if (nodePermutation[startIndex+1]) /* Wenn es noch weitere Knoten in der Queue gibt (im Abstand k+1) */
                {
                    return permutateEdgeList(nodePermutation, startIndex+1, stopIndex, currentTupel, depth+1);
                }
                else /* es gibt keine Knoten mehr, die einen größeren Abstand zum Zentrum haben. Die beiden Startpunkte werden in einem */
                {    /* Automorphismus aufeinander Abgebildet */
                    return 0;
                }
            }
        }

        while (currentEdge) /* Teste, ob die aktuelle Kante noch mit dem BFS Code übereinstimmt ...*/
        {
#ifdef DEBUG
            if (!currentTupel)
                printf("leeres tupel\n");
#endif

            if (currentTupel->firstNodeNr < currentTupel->secondNodeNr) /* Tupel aus BFS Code ist nicht umgedreht (NNB) */
            {
                if (currentTupel->firstNodeNr < currentEdge->edgeStartNode->vertexID)
                {
                    /* Gehe zurück zu dem Punkt, wo der Knoten mit der Nr. currentTupel->firstNodeNr gematcht wurde*/
                    return currentTupel->firstNodeNr;
                }
                if (currentTupel->firstNodeNr > currentEdge->edgeStartNode->vertexID)
                {
                    /* Gehe zurück zu dem Punkt, wo der Knoten mit der Nr. currentEdge->edgeStartNode->vertexID gematcht wurde*/
                    return currentEdge->edgeStartNode->vertexID;
                }
                if (currentEdge->edgeTarget->vertexID < 0)
                {
#ifdef DEBUG
                    if (currentTupel->firstNodeValue != currentEdge->edgeStartNode->vertexLabel)
                    {
                        fprintf(stderr,"Matching error1\n");
                        throw g_span_error;;
                    }
#endif
                    if (currentTupel->edgeValue==currentEdge->edgeLabel)
                    {
                        if (currentTupel->secondNodeValue==currentEdge->edgeTarget->vertexLabel) /* Kante stimmt mit BFS Tupel überein */
                        {
                            originalNodeID = currentEdge->edgeTarget->vertexID;
                            currentEdge->edgeTarget->vertexID = currentTupel->secondNodeNr;
                            removeEdgeFromEdgeList(currentEdge->reverseEdge);
                            removeEdgeFromEdgeList(currentEdge);
                            nodePermutation[currentTupel->secondNodeNr] = currentEdge->edgeTarget;
                            returnValue = permutateEdgeList(nodePermutation, startIndex, stopIndex, currentTupel->nextEdgeTupel, depth);
                            reinsertEdgeInEdgeList(currentEdge->reverseEdge);
                            reinsertEdgeInEdgeList(currentEdge);
                            nodePermutation[currentTupel->secondNodeNr] = NULL;

                            if (returnValue != currentEdge->edgeTarget->vertexID)
                            {
                                currentEdge->edgeTarget->vertexID = originalNodeID;
                                return returnValue;
                            }
                            currentEdge->edgeTarget->vertexID = originalNodeID;
                        }
                    }
                }
            }
            else /* BFS Tupel ist umgedreht, OCC oder ECC */
            {
                if (currentTupel->secondNodeNr < currentEdge->edgeStartNode->vertexID)
                {
                    /* Gehe zurück zu dem Punkt, wo der Knoten mit der Nr. currentTupel->secondNodeNr erstmals gematcht wurde*/
                    return currentTupel->secondNodeNr;
                }
                if (currentTupel->secondNodeNr > currentEdge->edgeStartNode->vertexID)
                {
                    /* Gehe zurück zu dem Punkt, wo der Knoten mit der Nr. currentEdge->edgeStartNode->vertexID gematcht wurde*/
                    return currentEdge->edgeStartNode->vertexID;
                }
                if (currentTupel->firstNodeNr == currentEdge->edgeTarget->vertexID)
                {
#ifdef DEBUG
                    if (currentTupel->secondNodeValue != currentEdge->edgeStartNode->vertexLabel)
                    {
                        fprintf(stderr,"Matching error2\n");
                        throw g_span_error;;
                    }
#endif
                    if (currentTupel->edgeValue==currentEdge->edgeLabel)
                    {
                        if (currentTupel->firstNodeValue == currentEdge->edgeTarget->vertexLabel) /* Kante stimmt mit BFS Tupel überein */
                        {
                            removeEdgeFromEdgeList(currentEdge->reverseEdge);
                            removeEdgeFromEdgeList(currentEdge);
                            returnValue = permutateEdgeList(nodePermutation, startIndex, stopIndex, currentTupel->nextEdgeTupel, depth);
                            reinsertEdgeInEdgeList(currentEdge->reverseEdge);
                            reinsertEdgeInEdgeList(currentEdge);
                            return returnValue;  /* Kante ist keine NNB, daher kann der gesuchte Knoten nicht erstmals hier auftauchen */
                        }
                    }
                }
            }
            currentEdge = currentEdge->nextEdgeListElement;
        }
        if (returnValue>0)
            return returnValue-1;
        else
            return currentTupel->firstNodeNr;
    }

    void removeEdgeFromEdgeList(edgeListElementPointer edge)
    {
        if (edge->previousEdgeListElement)  /* Damit die Kante nicht doppelt gefunden wird */
        {
            edge->previousEdgeListElement->nextEdgeListElement = edge->nextEdgeListElement;
        }
        else
        {
            edge->edgeStartNode->firstEdge = edge->nextEdgeListElement;
        }

        if (edge->nextEdgeListElement)
        {
            edge->nextEdgeListElement->previousEdgeListElement = edge->previousEdgeListElement;
        }
    }

    void reinsertEdgeInEdgeList(edgeListElementPointer edge)
    {
        if (edge->previousEdgeListElement)  /* Damit die Kante nicht doppelt gefunden wird */
        {
            edge->previousEdgeListElement->nextEdgeListElement = edge;
        }
        else
        {
            edge->edgeStartNode->firstEdge = edge;
        }

        if (edge->nextEdgeListElement)
        {
            edge->nextEdgeListElement->previousEdgeListElement = edge;
        }
    }

    int* computeBfsCode(graphPointer currentGraph, graphNodePointer currentStartNode)
    {
        int i;

        graphNodePointer kDistantNodes[maxNodeCount]; /* Diese Liste enthält Zeiger auf die Knoten im Abstand k zum zentralen Knoten */
        kDistantNodes[0] = currentStartNode;
        for (i=1;i<maxNodeCount;i++)
            kDistantNodes[i] = NULL;

        int *distanceLevelSize = (int*)al.malloc(currentGraph->nodeCount*sizeof(int)); /* Speichert die Anzahl der Knoten im Abstand i zum Zentrum */
        distanceLevelSize[0] = 1;
        for (i=1;i<currentGraph->nodeCount;i++)
            distanceLevelSize[i] = 0;

        originalNodeIDs[0]= currentStartNode->vertexID;   /* Speichert die OriginalIDs der Knoten, die gematcht (und umbenannt) wurden */
        currentStartNode->vertexID = 0;
        matchedNodeCount = 1;

        bfsCode = NULL;    /* Pointer auf das erste Edge Tupel des zu erzeugenden BFS Codes */
        extendEnvironment(bfsCode, kDistantNodes, maxNodeCount, distanceLevelSize, 1); /* Erweitere den BFS Code */
        //edgeTupelPointer codeIterator = bfsCode;
        currentStartNode->vertexID = originalNodeIDs[0];
        return distanceLevelSize;
    }
    /**************************************/
    int* computeBfsCode2(graphPointer currentGraph, graphNodePointer currentStartNode)
    {
        int i;

        graphNodePointer kDistantNodes[maxNodeCount]; /* Diese Liste enthält Zeiger auf die Knoten im Abstand k zum zentralen Knoten */
        kDistantNodes[0] = currentStartNode;
        for (i=1;i<maxNodeCount;i++)
            kDistantNodes[i] = NULL;

        int *distanceLevelSize = (int*)al.malloc(currentGraph->nodeCount*sizeof(int)); /* Speichert die Anzahl der Knoten im Abstand i zum Zentrum */
        distanceLevelSize[0] = 1;
        for (i=1;i<currentGraph->nodeCount;i++)
            distanceLevelSize[i] = 0;

        originalNodeIDs[0]= currentStartNode->vertexID;   /* Speichert die OriginalIDs der Knoten, die gematcht (und umbenannt) wurden */
        currentStartNode->vertexID = 0;
        matchedNodeCount = 1;
        bfsCode = NULL;    /* Pointer auf das erste Edge Tupel des zu erzeugenden BFS Codes */
        extendEnvironment2(bfsCode, kDistantNodes, maxNodeCount, distanceLevelSize, 1); /* Erweitere den BFS Code */
        currentStartNode->vertexID = originalNodeIDs[0];
        return distanceLevelSize;
    }

    void extendEnvironment(edgeTupelPointer lastBfsTupel, graphNodePointer *kDistantNodes, int listSize, int *distanceLevelSize, int distance)
    {
        int i;
        //int j;
        int targetID;

        edgeTupelPointer newTupel = NULL;
        edgeListElementPointer reverseEdge = NULL;
        edgeListElementPointer edgeIterator = NULL;
        //edgeListElementPointer tempEdgeIterator = NULL;
        graphNodePointer kPlusOneDistantNodes[maxNodeCount]; /* die Liste der Knoten im Abstand k+1, wird in dieser Funktion erzeugt */
        int kPlusOneNodeCount = 0;                           /* Zählt mit wieviele Knoten im Abstand k+1 gefunden werden */

        for (i=0;i<listSize && kDistantNodes[i];i++)  /* Iteriere über die Knoten im Abstand k, über deren Kinder wird die Liste */
        {                                                       /* der Knoten im Abstand k+1 gebildet */
            edgeIterator = kDistantNodes[i]->firstEdge;   /* Iteriere über die Kanten der Elternknoten (Knoten der Tiefe k) */
            while (edgeIterator)                         /* Die Zielknoten dieser Kanten bilden die Knoten der Tiefe k+1 */
            {
                newTupel = NULL;
                newTupel = (edgeTupelPointer)al.malloc(sizeof(edgeTupel));   /* Erzeugen eines neuen BFS Tupels, das der Kante entspricht */
                newTupel->edgeValue = edgeIterator->edgeLabel;
                newTupel->nextEdgeTupel = NULL;

                targetID = edgeIterator->edgeTarget->vertexID;

                if (targetID<0)   /* Kante führt einen neuen Knoten in BFS Code ein (new node bridge) */
                {
                    newTupel->firstNodeNr = kDistantNodes[i]->vertexID;
                    newTupel->secondNodeNr = matchedNodeCount;
                    newTupel->firstNodeValue = kDistantNodes[i]->vertexLabel;
                    newTupel->secondNodeValue = edgeIterator->edgeTarget->vertexLabel;

                    originalNodeIDs[matchedNodeCount] = edgeIterator->edgeTarget->vertexID;  /* Speichern der OriginalID und */
                    edgeIterator->edgeTarget->vertexID = matchedNodeCount;                   /* umbenennen des Zielknotens */
                    matchedNodeCount++;         /* globaler Zähler für die Anzahl der Knoten, die bereits in BFS Code aufgenommen wurden */
                    kPlusOneDistantNodes[kPlusOneNodeCount] = edgeIterator->edgeTarget;
                    kPlusOneNodeCount++;
                }
                else    /* Kante ist ECC oder OCC, daher müssen Start- und Zielknoten umgedreht werden */
                {
                    newTupel->secondNodeNr = kDistantNodes[i]->vertexID;
                    newTupel->firstNodeNr = targetID;
                    newTupel->secondNodeValue = kDistantNodes[i]->vertexLabel;
                    newTupel->firstNodeValue = edgeIterator->edgeTarget->vertexLabel;
                }

                if (lastBfsTupel)
                {
                    lastBfsTupel->nextEdgeTupel = newTupel;        /* Anhängen des neuen Tupels an den BFS Code */
                    newTupel->previousEdgeTupel = lastBfsTupel;
                }
                else
                {
                    bfsCode = newTupel;
                    newTupel->previousEdgeTupel = NULL;
                }
                lastBfsTupel = newTupel;

                removeEdgeFromEdgeList(edgeIterator->reverseEdge);
                reverseEdge = edgeIterator->reverseEdge;   /* Reverses der Kante wird temporär aus den Kantenlisten des Graphen entfernt */

                edgeIterator = edgeIterator->nextEdgeListElement;  /* Weiter mit nächster Kante des gerade betrachteten Knoten */
            }
        }

        if (kPlusOneNodeCount>0)     /* Wenn es in der nächsten Ebene noch Knoten gibt, rekursiver Aufruf der Funktion */
        {
            distanceLevelSize[distance] = kPlusOneNodeCount;/* Füllen des distanceLevelSize Arrays für spätere Berechn. der BFS Permutation */

            extendEnvironment(lastBfsTupel, kPlusOneDistantNodes, kPlusOneNodeCount, distanceLevelSize, distance+1);
        }

        for (i=0;i<listSize && kDistantNodes[i];i++)  /* Iterieren über alle Knoten im Abstand k und deren Kanten um die Reversen der */
        {                                                   /* Kante wiedereinzufügen und die OriginalID der Zielknoten wiederherzustellen */
            edgeIterator = kDistantNodes[i]->firstEdge;
            while (edgeIterator)
            {
                if (edgeIterator->edgeTarget->vertexID >= 0)
                {
                    edgeIterator->edgeTarget->vertexID = originalNodeIDs[edgeIterator->edgeTarget->vertexID];
                }
                reverseEdge = edgeIterator->reverseEdge;
                if (reverseEdge->previousEdgeListElement)
                    reverseEdge->previousEdgeListElement->nextEdgeListElement = reverseEdge;
                else
                    reverseEdge->edgeStartNode->firstEdge = reverseEdge;

                if (reverseEdge->nextEdgeListElement)
                    reverseEdge->nextEdgeListElement->previousEdgeListElement = reverseEdge;
                edgeIterator = edgeIterator->nextEdgeListElement;
            }
        }
    }

    /**********************/

    void extendEnvironment2(edgeTupelPointer lastBfsTupel, graphNodePointer *kDistantNodes, int listSize, int *distanceLevelSize, int distance)
    {
        int i;
        //int j;
        int targetID;

        edgeTupelPointer newTupel = NULL;
        edgeListElementPointer reverseEdge = NULL;
        edgeListElementPointer edgeIterator = NULL;
        //edgeListElementPointer tempEdgeIterator = NULL;
        graphNodePointer kPlusOneDistantNodes[maxNodeCount]; /* die Liste der Knoten im Abstand k+1, wird in dieser Funktion erzeugt */
        int kPlusOneNodeCount = 0;                           /* Zählt mit wieviele Knoten im Abstand k+1 gefunden werden */

        for (i=0;i<listSize && kDistantNodes[i];i++)  /* Iteriere über die Knoten im Abstand k, über deren Kinder wird die Liste */
        {
            edgeIterator = kDistantNodes[i]->firstEdge;   /* Iteriere über die Kanten der Elternknoten (Knoten der Tiefe k) */
            while (edgeIterator)                         /* Die Zielknoten dieser Kanten bilden die Knoten der Tiefe k+1 */
            {
                edgeIterator = edgeIterator->nextEdgeListElement;  /* Weiter mit nächster Kante des gerade betrachteten Knoten */
            }                                                    /* der Knoten im Abstand k+1 gebildet */
            edgeIterator = kDistantNodes[i]->firstEdge;   /* Iteriere über die Kanten der Elternknoten (Knoten der Tiefe k) */
            while (edgeIterator)                         /* Die Zielknoten dieser Kanten bilden die Knoten der Tiefe k+1 */
            {
                newTupel = NULL;
                newTupel = (edgeTupelPointer)al.malloc(sizeof(edgeTupel));   /* Erzeugen eines neuen BFS Tupels, das der Kante entspricht */
                newTupel->edgeValue = edgeIterator->edgeLabel;
                newTupel->nextEdgeTupel = NULL;

                if (edgeIterator == secondEdgeIt->reverseEdge)    /* Wird benötigt um zu wissen wo die Kante im BFS code vorkommt */
                    secondSiblingEdge = newTupel;

                targetID = edgeIterator->edgeTarget->vertexID;

                if (targetID<0)   /* Kante führt einen neuen Knoten in BFS Code ein (new node bridge) */
                {
                    newTupel->firstNodeNr = kDistantNodes[i]->vertexID;
                    newTupel->secondNodeNr = matchedNodeCount;
                    newTupel->firstNodeValue = kDistantNodes[i]->vertexLabel;
                    newTupel->secondNodeValue = edgeIterator->edgeTarget->vertexLabel;

                    originalNodeIDs[matchedNodeCount] = edgeIterator->edgeTarget->vertexID;  /* Speichern der OriginalID und */
                    edgeIterator->edgeTarget->vertexID = matchedNodeCount;                   /* umbenennen des Zielknotens */
                    matchedNodeCount++;         /* globaler Zähler für die Anzahl der Knoten, die bereits in BFS Code aufgenommen wurden */
                    kPlusOneDistantNodes[kPlusOneNodeCount] = edgeIterator->edgeTarget;
                    kPlusOneNodeCount++;
                }
                else    /* Kante ist ECC oder OCC, daher müssen Start- und Zielknoten umgedreht werden */
                {
                    newTupel->secondNodeNr = kDistantNodes[i]->vertexID;
                    newTupel->firstNodeNr = targetID;
                    newTupel->secondNodeValue = kDistantNodes[i]->vertexLabel;
                    newTupel->firstNodeValue = edgeIterator->edgeTarget->vertexLabel;
                }

                if (lastBfsTupel)
                {
                    lastBfsTupel->nextEdgeTupel = newTupel;        /* Anhängen des neuen Tupels an den BFS Code */
                    newTupel->previousEdgeTupel = lastBfsTupel;
                }
                else
                {
                    bfsCode = newTupel;
                    newTupel->previousEdgeTupel = NULL;
                }
                lastBfsTupel = newTupel;

                removeEdgeFromEdgeList(edgeIterator->reverseEdge);
                reverseEdge = edgeIterator->reverseEdge;   /* Reverses der Kante wird temporär aus den Kantenlisten des Graphen entfernt */

                edgeIterator = edgeIterator->nextEdgeListElement;  /* Weiter mit nächster Kante des gerade betrachteten Knoten */
            }
        }

        if (kPlusOneNodeCount>0)     /* Wenn es in der nächsten Ebene noch Knoten gibt, rekursiver Aufruf der Funktion */
        {
            distanceLevelSize[distance] = kPlusOneNodeCount;/* Füllen des distanceLevelSize Arrays für spätere Berechn. der BFS Permutation */

            extendEnvironment2(lastBfsTupel, kPlusOneDistantNodes, kPlusOneNodeCount, distanceLevelSize, distance+1);
        }

        for (i=0;i<listSize && kDistantNodes[i];i++)  /* Iterieren über alle Knoten im Abstand k und deren Kanten um die Reversen der */
        {                                                   /* Kante wiedereinzufügen und die OriginalID der Zielknoten wiederherzustellen */
            edgeIterator = kDistantNodes[i]->firstEdge;
            while (edgeIterator)
            {
                if (edgeIterator->edgeTarget->vertexID >= 0)
                {
                    edgeIterator->edgeTarget->vertexID = originalNodeIDs[edgeIterator->edgeTarget->vertexID];
                }
                reverseEdge = edgeIterator->reverseEdge;
                if (reverseEdge->previousEdgeListElement)
                    reverseEdge->previousEdgeListElement->nextEdgeListElement = reverseEdge;
                else
                    reverseEdge->edgeStartNode->firstEdge = reverseEdge;

                if (reverseEdge->nextEdgeListElement)
                    reverseEdge->nextEdgeListElement->previousEdgeListElement = reverseEdge;
                edgeIterator = edgeIterator->nextEdgeListElement;
            }
        }
    }



/////////////////////////////////////////////////////////////
// gSpan.c
/////////////////////////////////////////////////////////////






// void removeEdgeFromDB(graphDatabasePointer graphDBpointer, edgeTupelPointer k);
// void tempRemoveEdge(edgeListElementPointer edge);

// boolean subgraphMining(edgeTupelPointer k);
// void findSubgraphOccurrences();
    boolean findEdge(ELEP currentEdge, int i, superGraphPointer superGraph);
// void extendNode(graphNodePointer node, int i);
// void generatePotentialChildren();
// void insertInBwTable(edgeListElementPointer edgeExtension);
// void insertInFw1Table(edgeListElementPointer edgeExtension);
// edgeTupelPointer insertInFw2Table(edgeListElementPointer edgeExtension, int l);
// void enumEmbeddings(matchEdgeListElementPointer matchListElement);
// edgeListElementPointer *copyEdgeMatchList();
// void insertInMatchEdgeList(edgeListElementPointer *emlCopy);
// void extendNodeSymm(graphNodePointer node, int i);
// void printStatistic();
// void printUsage();

    /************* Externe Variablen ***********/

// extern edgeTupelPointer freqOneEdgeGraphs;
// extern graphDatabasePointer newDB;
// extern int minDFSCode;
// extern int notMinDFSCode;
// extern int edgeLabelCount;
// extern int nodeLabelCount;
// extern int maxNodeCount;
// extern int maxEdgeCount;


    /*********** Globale Variablen ***********/

// int minSup;// = 25;
//char *filename;// = "Chemical_340";
// graphPointer currentGraph = NULL;             /* Zeigt auf den gerade betrachteten Graphen */
// edgeTupelPointer currentEdgeTupel = NULL;     /* Das zuletzt hinzugef?gte Tupel in einem DFS-Code */
// int currentSubgraphSize = 0;                  /* Anzahl der Kanten im aktuellen Subgraph, i.e. die L?nge des dfsCode Arrays */
// int maxSubgraphSize;
// int freqSubgraphCount = 0;         /* Zum Ermitteln der Gesamtzahl h?ufiger Subgraphen */
// int oldFreqSubgraphCount = 0;
// //int maxFragSize;
//
//
// int *nodeID2RightestPathPosition;      /* Gibt zu firstNodeNr bzw. edgeStartNode->vertexID die Position des Tupels auf rechtestem Pfad */
// int *rightestPathPosition2edgeTupelNr;   /* Gibt zu einem int (Position eines Tupels im rechtesten Pfad) die Position des Tupels im */
// /* DFS Code zur?ck. (zum Bestimmen der Erweiterungen, die vom rechtesten Pfad ausgehen */
// int fw2ExtensionCount = 0;
// int remainingFw2Extensions;
// int *fw2ExtensionCountArray;
// int *remainingFw2ExtensionsArray;
// edgeTupelPointer *dfsCode;
// edgeTupelPointer **bwTable;
// edgeTupelPointer **fw1Table;
// edgeTupelPointer ***fw2Table;
// boolean ***fw2CandidateTable;
// edgeListElementPointer *edgeMatchList;
// superGraphPointer superGraph = NULL;
// graphNodePointer firstNodeOfSubgraph = NULL;
// graphNodePointer lastNodeOfSubgraph = NULL;
//
// #ifdef DEBUG
// int removedGraphs = 0;
// int occInGraph;
// int forkCount = 0;
// int forkCount2 = 0;
// int unsuccessfulCandidateCount = 0;
// #endif
//
// #ifdef CLOCK
// clock_t startEnumEmb, stopEnumEmb;
// clock_t startMatch, stopMatch;
// double enumDur = 0;
// double matchDur = 0;
// #endif
//
// //#ifdef SYMMETRY
// int biConnCompNr;
// //#endif
//
// //#ifdef AUSGABE
// FILE *output;
// //#endif
//
//
// int maxFragSize = -1;
// boolean useSymm = FALSE;
// boolean useAscFreqOrder = FALSE;
// boolean useEmbLists = FALSE;
// int hybridThreshold = -1;
// boolean findOnlyTrees = FALSE;
// boolean findOnlyPaths = FALSE;
// int minSup = -1;
// boolean createOutput = TRUE;
// char *filename = NULL;
// char *outputfile = NULL;
// double threshold;
//
// int Relabel_Dictionary_Node[MAX_NODE_TYPES];
// int Relabel_Dictionary_Edge[MAX_EDGE_TYPES];
//     boolean mainxxx(int argc, char *argv[])
//     {
// 
//         if (argc < 3)
//         {
//             printUsage();
//             throw g_span_error();
//         }
//         int i = 1;
//         while (i < argc-1)
//         {
//             if (argv[i][0] == '-')
//             {
//                 if (argv[i][1] == 'm')
//                 {
//                     i++;
//                     maxFragSize = atoi(argv[i]);
//                 }
//                 else if (argv[i][1] == 's')
//                 {
//                     useSymm = TRUE;
//                 }
//                 else if (argv[i][1] == 'a')
//                 {
//                     useAscFreqOrder = TRUE;
//                 }
//                 else if (argv[i][1] == 'e')
//                 {
//                     useEmbLists = TRUE;
//                 }
//                 else if (argv[i][1] == 'h')
//                 {
//                     i++;
//                     useEmbLists = TRUE;
//                     hybridThreshold = atoi(argv[i]);
//                 }
//                 else if (argv[i][1] == 't')
//                 {
//                     findOnlyTrees = TRUE;
//                 }
//                 else if (argv[i][1] == 'p')
//                 {
//                     findOnlyPaths = TRUE;
//                 }
//                 else
//                 {
//                     //fprintf(stderr,"Unknown option -%s\n\n",*argv[i]);
//                     printUsage();
//                     throw g_span_error();
//                 }
//             }
//             else
//             {
//                 break;
//             }
// 
//             i++;
//         }
//         
//         if (argv[i])
//         {
//             minSup = atoi(argv[i]);
//             if (argv[i+1])
//             {
//                 filename = argv[i+1];
//                 if (argv[i+2])
//                 {
//                     threshold = atof(argv[i+2]);
//                     createOutput = TRUE;
//                     /*if(argv[i+3])
//                     {
//                             outputfile = argv[i+3];
//                             createOutput = TRUE;
//                     }*/
//                 }
//             }
//             else
//             {
//                 printUsage();
//                 throw g_span_error();
//             }
//         }
//         else
//         {
//             printUsage();
//             throw g_span_error();
//         }
// 
// //      if(minSup <= 0)
// //      {
// //              fprintf(stderr, "<minSup> in not a positive integer\n");
// //              fprintf(stderr, "Usage: ./a.out <filename> <minSup> (<maxFragSize>)\n");
// //              exit(1);
// //      }
//         printf( "filename: %s\n", filename );
//         preprocessDB(filename);
//         //printf("preprocessing finished\n");
// 
// //      #ifdef MAXFRAGSIZE
// //      if(argc >= 4)
// //              maxFragSize = atoi(argv[3]);
// //      else
//         if (maxFragSize == -1)
//             maxFragSize = maxEdgeCount;
// //      #endif
// 
//         dfsCode = (edgeTupelPointer*)al.malloc(maxEdgeCount*sizeof(edgeTupelPointer));            /* Ein h?ufiger Subgraph kann h?chstens so */
//         edgeMatchList = (edgeListElementPointer*)al.malloc(maxEdgeCount*sizeof(edgeListElement)); /* gro? sein, wie der gr??te Graph in der DB */
// 
//         if (maxNodeCount<3)
//         {
//             maxNodeCount = 3;    /* sonst sind irgendwelche Arrays nicht definiert !!! */
//         }
//         if (edgeLabelCount == 0)
//         {
//             printf("No edges in DB!!!!!!!\n");
//             throw g_span_error();
//         }
//         if (nodeLabelCount == 0)
//         {
//             printf("No nodes in DB!!!!!!!\n");
//             throw g_span_error();
//         }
// 
//         int j,k;
// 
//         nodeID2RightestPathPosition = (int*)al.malloc(maxNodeCount*sizeof(int));           /* max. L?nge eines rechtesten Pfades <= max. Pfadl?nge in */
//         rightestPathPosition2edgeTupelNr = (int*)al.malloc((maxNodeCount)*sizeof(int));    /* den Graphen der DB <= maxNodeCount */
// 
//         fw2ExtensionCountArray = (int*)al.malloc(maxNodeCount*sizeof(int));       /* fw2Extensions k?nnen nur von den Startknoten der Kanten auf dem */
//         remainingFw2ExtensionsArray = (int*)al.malloc(maxNodeCount*sizeof(int));  /* rechtesten Pfad ausgehen, daher Absch?tzung der Gr??e wie oben */
// 
//         bwTable = (edgeTupelPointer**)al.malloc((maxNodeCount-2)*sizeof(edgeTupelPointer*));    /* Zielknoten einer bwEdge kann nur auf dem */
//         for (i=0;i<maxNodeCount-2;i++)                                                         /* rechtesten Pfad liegen und nicht direkter */
//         {                                                                                      /* Vorg?nger des Startknotens der bwEdge sein */
//             bwTable[i] = (edgeTupelPointer*)al.malloc(edgeLabelCount*sizeof(edgeTupelPointer));
//         }
// 
//         fw1Table = (edgeTupelPointer**)al.malloc(nodeLabelCount*sizeof(edgeTupelPointer*));
//         for (i=0;i<nodeLabelCount;i++)
//         {
//             fw1Table[i] = (edgeTupelPointer*)al.gc_malloc(edgeLabelCount*sizeof(edgeTupelPointer));
//         }
// 
//         fw2Table = (edgeTupelPointer***)al.malloc((maxNodeCount-1)*sizeof(edgeTupelPointer**));
//         for (i=0;i<maxNodeCount-1;i++)
//         {
//             fw2Table[i] = (edgeTupelPointer**)al.malloc(nodeLabelCount*sizeof(edgeTupelPointer*));
//             for (j=0;j<nodeLabelCount;j++)
//             {
//                 fw2Table[i][j] = (edgeTupelPointer*)al.gc_malloc(edgeLabelCount*sizeof(edgeTupelPointer));
//             }
//         }
// 
//         fw2CandidateTable = (boolean***)al.gc_malloc((maxNodeCount-1)*sizeof(boolean**));
//         for (i=0;i<maxNodeCount-1;i++)
//         {
//             fw2CandidateTable[i] = (boolean**)al.gc_malloc(nodeLabelCount*sizeof(boolean*));
//             for (j=0;j<nodeLabelCount;j++)
//             {
//                 fw2CandidateTable[i][j] = (boolean*)al.gc_malloc(edgeLabelCount*sizeof(boolean));
//             }
//         }
// 
//         for (i=0;i<maxNodeCount-2;i++)                                     /* Alle Eintr?ge werden mit NULL initialisiert, F?llen des */
//         {                                                                  /* Arrays erfolgt beim Durchlauf durch DB.  */
//             for (j=0;j<edgeLabelCount;j++)
//             {
//                 bwTable[i][j] = NULL;
//             }
//         }
//         for (i=0;i<nodeLabelCount;i++)              /* Alle Eintr?ge werden mit NULL initialisiert, F?llen des Arrays */
//         {                                           /* erfolgt beim Durchlauf durch DB. Arraygr??e kann nie 0 sein */
//             for (j=0;j<edgeLabelCount;j++)
//             {
//                 fw1Table[i][j] = NULL;
//             }
//         }
//         for (i=0;i<maxNodeCount-1;i++)  /* Alle Eintr?ge werden erstmal mit NULL initialisiert, die */
//         {                                                       /* potentiellen Erweiterungen k?nnen aus den rechten Siblings */
//             for (j=0;j<nodeLabelCount;j++)                     /* abgelesen werden, s.u. */
//             {
//                 for (k=0;k<edgeLabelCount;k++)
//                 {
//                     fw2Table[i][j][k] = NULL;
//                 }
//             }
//         }
// 
//         for (i=0;i<maxNodeCount-1;i++)  /* Alle Eintr?ge werden erstmal mit NULL initialisiert, die */
//         {                                                       /* potentiellen Erweiterungen k?nnen aus den rechten Siblings */
//             for (j=0;j<nodeLabelCount;j++)                     /* abgelesen werden, s.u. */
//             {
//                 for (k=0;k<edgeLabelCount;k++)
//                 {
//                     fw2CandidateTable[i][j][k] = FALSE;
//                 }
//             }
//         }
// 
//         edgeTupelPointer tupelIterator = freqOneEdgeGraphs;
//         edgeTupelPointer previousTupel = NULL;
// 
//         //#ifdef AUSGABE
//         //if(createOutput)
//         //  output = fopen(outputfile,"w");
//         //#endif
// 
//         firstNodeOfSubgraph = (graphNodePointer)al.gc_malloc(sizeof(graphNode));
//         lastNodeOfSubgraph = (graphNodePointer)al.gc_malloc(sizeof(graphNode));
//         edgeListElementPointer firstEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));
//         edgeListElementPointer reverseFirstEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));
// 
//         firstNodeOfSubgraph->vertexID = -1;
//         firstNodeOfSubgraph->nextNode = lastNodeOfSubgraph;
//         firstNodeOfSubgraph->firstEdge = firstEdge;
// 
//         lastNodeOfSubgraph->vertexID = -2;
//         lastNodeOfSubgraph->nextNode = NULL;
//         lastNodeOfSubgraph->firstEdge = reverseFirstEdge;
// 
//         firstEdge->edgeStartNode = firstNodeOfSubgraph;
//         firstEdge->edgeTarget = lastNodeOfSubgraph;
//         firstEdge->nextEdgeListElement = NULL;
//         firstEdge->previousEdgeListElement = NULL;
//         firstEdge->reverseEdge = reverseFirstEdge;
// 
//         reverseFirstEdge->edgeStartNode = lastNodeOfSubgraph;
//         reverseFirstEdge->edgeTarget = firstNodeOfSubgraph;;
//         reverseFirstEdge->nextEdgeListElement = NULL;
//         reverseFirstEdge->previousEdgeListElement = NULL;
//         reverseFirstEdge->reverseEdge = firstEdge;
// 
//         boolean result;
//         /******* Iterieren ?ber alle freq 1-edge graphs **************************/
// 
//         while (tupelIterator)   /*Iterator ?ber alle frequent 1-edge graphs, die Elemente von S^1 */
//         {
//             dfsCode[0] = tupelIterator;
//             currentSubgraphSize = 1;                 /* Anzahl der Kanten des aktuellen Subgraphen*/
// 
//             firstNodeOfSubgraph->vertexLabel = tupelIterator->firstNodeValue;
//             lastNodeOfSubgraph->vertexLabel = tupelIterator->secondNodeValue;
// 
//             firstEdge->edgeLabel = tupelIterator->edgeValue;
//             reverseFirstEdge->edgeLabel = tupelIterator->edgeValue;
// 
// #ifdef DEBUG
//             printf("new start tupel: (%d, %d, %d, %d, %d)\n", tupelIterator->firstNodeNr,tupelIterator->secondNodeNr,
//                    tupelIterator->firstNodeValue,tupelIterator->edgeValue,tupelIterator->secondNodeValue);
// #endif
// 
// 
//             result = subgraphMining(tupelIterator);
//             if (result == TRUE) {
//                 //printf("1");
//                 break;
//                 //return 1;
//             }
// 
//             /********** Entfernen von k aus der Graphdatenbank ********************/
// 
//             removeEdgeFromDB(newDB , tupelIterator);
// 
// #ifdef SPAVESAVER
//             removeSupergraphList(tupelIterator);
// #endif
// 
//             previousTupel = tupelIterator;
//             tupelIterator = tupelIterator->nextEdgeTupel;   /* setzt Iterator auf n?chsten freq 1-edge Tupel */
// #ifdef SPACESAVER
//             al.free(previousTupel);
// #endif
//         }
// 
//         /********************* FREE ***************************************************/
//         al.free(nodeID2RightestPathPosition);
//         nodeID2RightestPathPosition = NULL;
//         al.free(rightestPathPosition2edgeTupelNr);
//         al.free(fw2ExtensionCountArray);
//         al.free(remainingFw2ExtensionsArray);
// 
//         for (i=0;i<maxNodeCount-2;i++)
//         {
//             al.free(bwTable[i]);
//         }
//         al.free(bwTable);
// 
//         for (i=0;i<nodeLabelCount;i++)
//         {
//             al.free(fw1Table[i]);
//         }
//         al.free(fw1Table);
// 
//         for (i=0;i<maxNodeCount-1;i++)
//         {
//             for (j=0;j<nodeLabelCount;j++)
//             {
//                 al.free(fw2Table[i][j]);
//             }
//             al.free(fw2Table[i]);
//         }
//         al.free(fw2Table);
//         al.free(dfsCode);
//         al.free(edgeMatchList);
//         al.free(newDB);
// 
//         //printStatistic();
// 
//         //#ifdef AUSGABE
//         //if(createOutput)
//         //  fclose(output);
//         //#endif
//         if (result == TRUE) {
//             printf("1");
//             return 1;
//         }
//         else {
//             printf("0");
//             return 0;
//         }
//     }

    /***************************************************************************************/

    void printStatistic()
    {
        /*printf("minsup: %d\n",minSup);
        printf("Number of frequent Subgraphs: %d\n",freqSubgraphCount);
        printf("maxSubgraphSize: %d\n", maxSubgraphSize);
        #ifdef CLOCK
        printf("enum Dauer:  %f \n",enumDur/CLOCKS_PER_SEC);
        printf("match Dauer: %f \n",matchDur/CLOCKS_PER_SEC);
        #endif
        #ifdef DEBUG
        printf("forkCount:  %d\n",forkCount);
        printf("forkCount2: %d\n",forkCount2);
        printf("occInGraph: %d\n", occInGraph);
        printf("unsuccessfulCandidateCount: %d\n",unsuccessfulCandidateCount);
        printf("removedGraphs: %d\n",removedGraphs);*/
        //#endif
        return;
    }

    inline void check_timeout() {
        double time = gettime();
        
//         printf( "check timeout: %f %f\n", time, end_time );
        
        if( end_time > 0 && time > end_time ) {
            throw timeout_exception();
            
        }
    }

    boolean subgraphMining(ETP s)
    {
        check_timeout();
        
        
        if ((freqSubgraphCount % 1000) == 0 && freqSubgraphCount != oldFreqSubgraphCount)
        {
            //printf("%d\n",freqSubgraphCount);
            oldFreqSubgraphCount = freqSubgraphCount;
        }

        currentEdgeTupel = s;   // WICHTIG NICHT L?SCHEN !!!!!!!!!!!!!!!!!!!!!!!!
        freqSubgraphCount++;
        int i;
        int maxNodeDegreeFirst = 0;
        int maxNodeDegreeSecond = 0;

        //#ifdef AUSGABE
        if (createOutput)
        {
            //fprintf(output,"%d: %d\n",freqSubgraphCount, dfsCode[currentSubgraphSize-1]->superGraphList->size);
            for (i=0;i<currentSubgraphSize;i++)
            {

//                 fprintf(stdout,"(%d, %d, %d, %d, %d)\n", dfsCode[i]->firstNodeNr,
//                                                              dfsCode[i]->secondNodeNr,
//                                                             dfsCode[i]->firstNodeValue,
//                                                             dfsCode[i]->edgeValue,
//                                                             dfsCode[i]->secondNodeValue);
                if (dfsCode[i]->firstNodeNr > maxNodeDegreeFirst) {
                    maxNodeDegreeFirst = dfsCode[i]->firstNodeNr;
                }
                if (dfsCode[i]->secondNodeNr > maxNodeDegreeSecond) {
                    maxNodeDegreeSecond = dfsCode[i]->secondNodeNr;
                }

            }
            //printf( "end\n" );
            //printf("maxNodeDegree %d\n", max(maxNodeDegreeFirst,maxNodeDegreeSecond));
            //printf("threshold %f\n", threshold);
            
            //store all backbones of size threshold-1
            
            //std::cerr << "gspan: " << std::max(maxNodeDegreeFirst,maxNodeDegreeSecond) << " " << currentSubgraphSize << " " << threshold << "\n";
            
            

      
            if (std::max(maxNodeDegreeFirst,maxNodeDegreeSecond)>= (threshold-1)) {
                if(nrFrags==0){
                    minsizeSubgraphSize=std::max(maxNodeDegreeFirst,maxNodeDegreeSecond);
                }
                nrFrags=nrFrags+1;
                minBB=1;
                if(std::max(maxNodeDegreeFirst,maxNodeDegreeSecond)>minsizeSubgraphSize){
                    minBB=2;
                }
                //printf("maxNodeDegree %d\n", max(maxNodeDegreeFirst,maxNodeDegreeSecond));
                typename sdf_::mol_builder mb;
                    
                
                
                for(i=0;i<currentSubgraphSize;i++)
                {

//                     fprintf(output,"(%d, %d, %d, %d, %d)\n", dfsCode[i]->firstNodeNr,
//                                                                             dfsCode[i]->secondNodeNr,
//                                                                                                         dfsCode[i]->firstNodeValue,
//                                                                                                         dfsCode[i]->edgeValue,
//                                                                                                         dfsCode[i]->secondNodeValue);

                    /*printf("(%d, %d, %d, %d, %d)\n", dfsCode[i]->firstNodeNr,
                                                                            dfsCode[i]->secondNodeNr,
                                                                                                        dfsCode[i]->firstNodeValue,
                                                                                                        dfsCode[i]->edgeValue,
                                                                                                        dfsCode[i]->secondNodeValue);*/
                    int nv1 = m_atom_freqsort_backmap.at(dfsCode[i]->firstNodeValue);
                    int nv2 = m_atom_freqsort_backmap.at(dfsCode[i]->secondNodeValue);
                    int ev = m_bond_freqsort_backmap.at( dfsCode[i]->edgeValue );
                    
                    mb.add_bond( dfsCode[i]->firstNodeNr, dfsCode[i]->secondNodeNr, m_lm.rev_atom_type(nv1), m_lm.rev_atom_type(nv2), m_lm.rev_bond_type(ev) );

                    if(dfsCode[i]->firstNodeNr > maxNodeDegreeFirst){
                            maxNodeDegreeFirst = dfsCode[i]->firstNodeNr;
                    }
                    if(dfsCode[i]->secondNodeNr > maxNodeDegreeSecond){
                            maxNodeDegreeSecond = dfsCode[i]->secondNodeNr;
                    }
            
                }
                m_backbones.push_back( mb.get_mol() );
                
            
                
                //return TRUE;
//                 fprintf(output,"\n");

            }
            
            if(nrFrags==2 || (nrFrags == 1 && !m_search_second)){
                //printf("return nrFrags==2\n");
                return 1;
            }

            superGraphPointer supIt;
            for (supIt=dfsCode[currentSubgraphSize-1]->superGraphList->firstSuperGraph;supIt;supIt = supIt->nextSuperGraph)
            {
                //fprintf(output,"%d ",supIt->superGraphAdressInDB->graphNr);
            }

            //fprintf(output,"\n\n");
        }
        //#endif

        if (maxSubgraphSize < currentSubgraphSize)   /* Gr??e des gr??ten h?ufigen Subgraphen */
        {
            maxSubgraphSize = currentSubgraphSize;
        }

//      #ifdef MAXFRAGSIZE
        if((std::max(maxNodeDegreeFirst,maxNodeDegreeSecond)>minsizeSubgraphSize)&&(minsizeSubgraphSize>0))
        {
            nrFrags=nrFrags+1;
            minBB = 2;
            printf("sub %d\n",(std::max(maxNodeDegreeFirst,maxNodeDegreeSecond)));
            return 1;
        }
//      #endif

        /* F?llen der beiden Hilfsarrays zum Erzeugen der Kinder-Tupel des aktuellen Subgraphen. Das Array nodeID2RightestPathPosition */
        /* erm?glicht ?ber ID des Startknotens eines Tupels Zugriff auf die Position des Tupels im rechtesten Pfad, wichtig f?r bwEdges, */
        /* rightestPathPosition2edgeTupelNr erlaubt Iteration ?ber den rechtesten Pfad zur Bestimmung der fw2 Edges, die von den Startknoten */
        /* der Tupel auf dem rechtesten Pfad ausgehen */

        int tempID = std::max(dfsCode[currentSubgraphSize-1]->secondNodeNr,dfsCode[currentSubgraphSize-1]->firstNodeNr);
        for (i=currentSubgraphSize-1; i>=0; i--)
        {
            if (dfsCode[i]->secondNodeNr > dfsCode[i]->firstNodeNr)
            {
                if (dfsCode[i]->secondNodeNr == tempID)
                {
                    nodeID2RightestPathPosition[dfsCode[i]->firstNodeNr] = dfsCode[i]->lengthOfRightestPath-1;
                    rightestPathPosition2edgeTupelNr[dfsCode[i]->lengthOfRightestPath-1] = i;
                    tempID = dfsCode[i]->firstNodeNr;
                    //printf("%d ",tempID);
                }
                else
                {
                    nodeID2RightestPathPosition[dfsCode[i]->secondNodeNr] = -1;
                }
            }
        }

        findSubgraphOccurrences(); /* Findet alle Erweiterungen und erzeugt deren Supergraphlisten */

        /* Jetzt die Rekursiven Aufrufe f?r die Kinder von *s, des aktuellen Subgraphen */

        edgeTupelPointer childIterator = s->firstChildEdgeTupel;
        int oldSubgraphsize = currentSubgraphSize;

        /* Rekurisve Aufrufe ?ber die h?ufigen Kinder des aktuellen Subgraphen s */

        childIterator = s->firstChildEdgeTupel;
        edgeTupelPointer tempTupel;
        graphNodePointer startNode;       /* Startknoten der neuen Kante der Erweiterung */
        graphNodePointer targetNode;      /* Zielknoten der neuen Kante der Erweiterung */
        graphNodePointer secondLastNode;  /* Der zweitneueste Knoten */
        lastNodeOfSubgraph->nextNode = NULL;
        while (childIterator)
        {
            startNode = NULL;    /* DFS Code wird auch als Graph gespeichert, um effizienter auf Minimalit?t zu testen */
            targetNode = NULL;
            secondLastNode = lastNodeOfSubgraph;
            currentEdgeTupel = s;
            currentSubgraphSize = oldSubgraphsize+1;

            //      #ifdef MAXFRAGSIZE
            if (currentSubgraphSize > maxFragSize)
            {
                break;
            }
            //      #endif

            if (childIterator->secondNodeNr > childIterator->firstNodeNr) /* Neuer Knoten, der im Parentgraph noch nicht vorkam */
            {
                graphNodePointer targetNode = (graphNodePointer)al.gc_malloc(sizeof(graphNode));
                targetNode->vertexID = -(childIterator->secondNodeNr+1);
                targetNode->vertexLabel = childIterator->secondNodeValue;
                targetNode->nextNode = NULL;
                lastNodeOfSubgraph->nextNode = targetNode;
                lastNodeOfSubgraph = targetNode;
                targetNode->firstEdge = NULL;
            }

            graphNodePointer nodeIt;
            for (nodeIt = firstNodeOfSubgraph;nodeIt && (!startNode || !targetNode);nodeIt = nodeIt->nextNode) /* Finde neueste Kante im Graph */
            {
                if (!startNode)
                {
                    if (-(nodeIt->vertexID+1) == childIterator->firstNodeNr)
                        startNode = nodeIt;
                }
                if (!targetNode)
                {
                    if (-(nodeIt->vertexID+1) == childIterator->secondNodeNr)
                        targetNode = nodeIt;
                }
            }

          //  edgeTupelPointer parentEdgeTupel = childIterator->parentEdgeTupel; /* altes Tupel ist jetzt Parent-Tupel */

#ifdef DEBUG
            if (!startNode)
            {
                printf("Kein Startknoten\n");
            }
#endif
            edgeListElementPointer newEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));     /* Erzeuge neue Kante zum Einfügen in*/
            edgeListElementPointer newReverseEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));/* Graphdarstellung des Subgraphs*/
            newEdge->edgeLabel = childIterator->edgeValue;
            newEdge->edgeStartNode = startNode;
            newEdge->edgeTarget = targetNode;
            newEdge->nextEdgeListElement = startNode->firstEdge;
            startNode->firstEdge->previousEdgeListElement = newEdge;
            newEdge->previousEdgeListElement = NULL;
            newEdge->reverseEdge = newReverseEdge;
            newReverseEdge->edgeLabel = childIterator->edgeValue;
            newReverseEdge->edgeStartNode = targetNode;
            newReverseEdge->edgeTarget = startNode;
            newReverseEdge->nextEdgeListElement = targetNode->firstEdge;
            if (targetNode->firstEdge)
                targetNode->firstEdge->previousEdgeListElement = newReverseEdge;
            newReverseEdge->previousEdgeListElement = NULL;
            newReverseEdge->reverseEdge = newEdge;

            startNode->firstEdge = newEdge;
            targetNode->firstEdge = newReverseEdge;

            /****************************************************************/

            tempTupel = childIterator->nextEdgeTupel;
            dfsCode[currentSubgraphSize-1] = childIterator;
            if (minxxx(currentSubgraphSize))
            {
                int result = 0;
                result = subgraphMining(childIterator);
                if (result == 1)
                {
                    return TRUE;
                }
#ifdef SPACESAVER
                removeSupergraphList(childIterator);
                al.free(childIterator);
#endif
            }
            else
            {
                removeSupergraphList(childIterator);
                al.free(childIterator);
            }

            lastNodeOfSubgraph = secondLastNode;

            if (newEdge->previousEdgeListElement)   /* Entferne neueste Kante wieder aus Graphdarstellung des aktullen Subgraphen */
                newEdge->previousEdgeListElement->nextEdgeListElement = newEdge->nextEdgeListElement;
            else
                startNode->firstEdge = newEdge->nextEdgeListElement;
            if (newEdge->nextEdgeListElement)
                newEdge->nextEdgeListElement->previousEdgeListElement = newEdge->previousEdgeListElement;

            if (newReverseEdge->previousEdgeListElement)
                newReverseEdge->previousEdgeListElement->nextEdgeListElement = newReverseEdge->nextEdgeListElement;
            else
                targetNode->firstEdge = newReverseEdge->nextEdgeListElement;
            if (newReverseEdge->nextEdgeListElement)
                newReverseEdge->nextEdgeListElement->previousEdgeListElement = newReverseEdge->previousEdgeListElement;

            if (!targetNode->firstEdge)
            {
                secondLastNode->nextNode = NULL;
                al.free(targetNode);
            }
            al.free(newEdge);
            al.free(newReverseEdge);
            childIterator = tempTupel;
        }
        currentSubgraphSize = oldSubgraphsize;
        dfsCode[currentSubgraphSize-1] = NULL;
        return FALSE;
    }

    boolean subgraphMining2(ETP s)
    {
        check_timeout();
        
        
        if ((freqSubgraphCount % 1000) == 0 && freqSubgraphCount != oldFreqSubgraphCount)
        {
            //printf("%d\n",freqSubgraphCount);
            oldFreqSubgraphCount = freqSubgraphCount;
        }

        currentEdgeTupel = s;   // WICHTIG NICHT L?SCHEN !!!!!!!!!!!!!!!!!!!!!!!!
        freqSubgraphCount++;
        int i;
        int maxNodeDegreeFirst = 0;
        int maxNodeDegreeSecond = 0;

        //#ifdef AUSGABE
        if (createOutput)
        {
            //fprintf(output,"%d: %d\n",freqSubgraphCount, dfsCode[currentSubgraphSize-1]->superGraphList->size);
            for (i=0;i<currentSubgraphSize;i++)
            {

//                 fprintf(stdout,"(%d, %d, %d, %d, %d)\n", dfsCode[i]->firstNodeNr,
//                                                              dfsCode[i]->secondNodeNr,
//                                                             dfsCode[i]->firstNodeValue,
//                                                             dfsCode[i]->edgeValue,
//                                                             dfsCode[i]->secondNodeValue);
                if (dfsCode[i]->firstNodeNr > maxNodeDegreeFirst) {
                    maxNodeDegreeFirst = dfsCode[i]->firstNodeNr;
                }
                if (dfsCode[i]->secondNodeNr > maxNodeDegreeSecond) {
                    maxNodeDegreeSecond = dfsCode[i]->secondNodeNr;
                }

            }
            //printf( "end\n" );
            //printf("maxNodeDegree %d\n", max(maxNodeDegreeFirst,maxNodeDegreeSecond));
            //printf("threshold %f\n", threshold);
            
            //store all backbones of size threshold-1
            
            //std::cerr << "gspan: " << std::max(maxNodeDegreeFirst,maxNodeDegreeSecond) << " " << currentSubgraphSize << " " << threshold << "\n";
            int md = std::max(maxNodeDegreeFirst,maxNodeDegreeSecond);
            if ( md >= (threshold-2) && md < (threshold-1)) {
                //printf("maxNodeDegree %d\n", max(maxNodeDegreeFirst,maxNodeDegreeSecond));
 
                if( !false ) {
                    typename sdf_::mol_builder mb;
                    
                    for (i=0;i<currentSubgraphSize;i++)
                    {
                        int nv1 = m_atom_freqsort_backmap.at(dfsCode[i]->firstNodeValue);
                        int nv2 = m_atom_freqsort_backmap.at(dfsCode[i]->secondNodeValue);
                        int ev = m_bond_freqsort_backmap.at( dfsCode[i]->edgeValue );
                        
    //                     fprintf(stdout,"(%d, %d, %c, %d, %c)\n", dfsCode[i]->firstNodeNr,
    //                                                              dfsCode[i]->secondNodeNr,
    //                                                             m_lm.rev_atom_type(nv1)[1],
    //                                                             ev,
    //                                                             m_lm.rev_atom_type(nv2)[1]);
                        
                        mb.add_bond( dfsCode[i]->firstNodeNr, dfsCode[i]->secondNodeNr, m_lm.rev_atom_type(nv1), m_lm.rev_atom_type(nv2), m_lm.rev_bond_type(ev) );
                    }
//                     std::cerr << "push bb\n";
                    m_backbones.push_back( mb.get_mol() );
                    
//                     std::cout << "backbone: " << m_backbone.m_atoms.size();
                    //mb.print_mol( mb.get_mol() );
                // sdf_::write_mdl( mp.get_mol(), std::cout );
                }
            }

            // terminate on threshold
            if (std::max(maxNodeDegreeFirst,maxNodeDegreeSecond)>= (threshold-1)) {
                return TRUE;
            }
            superGraphPointer supIt;
            for (supIt=dfsCode[currentSubgraphSize-1]->superGraphList->firstSuperGraph;supIt;supIt = supIt->nextSuperGraph)
            {
                //fprintf(output,"%d ",supIt->superGraphAdressInDB->graphNr);
            }

            //fprintf(output,"\n\n");
        }
        //#endif

        if (maxSubgraphSize < currentSubgraphSize)   /* Gr??e des gr??ten h?ufigen Subgraphen */
        {
            maxSubgraphSize = currentSubgraphSize;
        }

//      #ifdef MAXFRAGSIZE
        if (currentSubgraphSize >= maxFragSize)
        {
            //printf("%d\n",currentSubgraphSize);
            return FALSE;
        }
//      #endif

        /* F?llen der beiden Hilfsarrays zum Erzeugen der Kinder-Tupel des aktuellen Subgraphen. Das Array nodeID2RightestPathPosition */
        /* erm?glicht ?ber ID des Startknotens eines Tupels Zugriff auf die Position des Tupels im rechtesten Pfad, wichtig f?r bwEdges, */
        /* rightestPathPosition2edgeTupelNr erlaubt Iteration ?ber den rechtesten Pfad zur Bestimmung der fw2 Edges, die von den Startknoten */
        /* der Tupel auf dem rechtesten Pfad ausgehen */

        int tempID = std::max(dfsCode[currentSubgraphSize-1]->secondNodeNr,dfsCode[currentSubgraphSize-1]->firstNodeNr);
        for (i=currentSubgraphSize-1; i>=0; i--)
        {
            if (dfsCode[i]->secondNodeNr > dfsCode[i]->firstNodeNr)
            {
                if (dfsCode[i]->secondNodeNr == tempID)
                {
                    nodeID2RightestPathPosition[dfsCode[i]->firstNodeNr] = dfsCode[i]->lengthOfRightestPath-1;
                    rightestPathPosition2edgeTupelNr[dfsCode[i]->lengthOfRightestPath-1] = i;
                    tempID = dfsCode[i]->firstNodeNr;
                    //printf("%d ",tempID);
                }
                else
                {
                    nodeID2RightestPathPosition[dfsCode[i]->secondNodeNr] = -1;
                }
            }
        }

        findSubgraphOccurrences(); /* Findet alle Erweiterungen und erzeugt deren Supergraphlisten */

        /* Jetzt die Rekursiven Aufrufe f?r die Kinder von *s, des aktuellen Subgraphen */

        edgeTupelPointer childIterator = s->firstChildEdgeTupel;
        int oldSubgraphsize = currentSubgraphSize;

        /* Rekurisve Aufrufe ?ber die h?ufigen Kinder des aktuellen Subgraphen s */

        childIterator = s->firstChildEdgeTupel;
        edgeTupelPointer tempTupel;
        graphNodePointer startNode;       /* Startknoten der neuen Kante der Erweiterung */
        graphNodePointer targetNode;      /* Zielknoten der neuen Kante der Erweiterung */
        graphNodePointer secondLastNode;  /* Der zweitneueste Knoten */
        lastNodeOfSubgraph->nextNode = NULL;
        while (childIterator)
        {
            startNode = NULL;    /* DFS Code wird auch als Graph gespeichert, um effizienter auf Minimalit?t zu testen */
            targetNode = NULL;
            secondLastNode = lastNodeOfSubgraph;
            currentEdgeTupel = s;
            currentSubgraphSize = oldSubgraphsize+1;

            //      #ifdef MAXFRAGSIZE
            if (currentSubgraphSize > maxFragSize)
            {
                break;
            }
            //      #endif

            if (childIterator->secondNodeNr > childIterator->firstNodeNr) /* Neuer Knoten, der im Parentgraph noch nicht vorkam */
            {
                graphNodePointer targetNode = (graphNodePointer)al.gc_malloc(sizeof(graphNode));
                targetNode->vertexID = -(childIterator->secondNodeNr+1);
                targetNode->vertexLabel = childIterator->secondNodeValue;
                targetNode->nextNode = NULL;
                lastNodeOfSubgraph->nextNode = targetNode;
                lastNodeOfSubgraph = targetNode;
                targetNode->firstEdge = NULL;
            }

            graphNodePointer nodeIt;
            for (nodeIt = firstNodeOfSubgraph;nodeIt && (!startNode || !targetNode);nodeIt = nodeIt->nextNode) /* Finde neueste Kante im Graph */
            {
                if (!startNode)
                {
                    if (-(nodeIt->vertexID+1) == childIterator->firstNodeNr)
                        startNode = nodeIt;
                }
                if (!targetNode)
                {
                    if (-(nodeIt->vertexID+1) == childIterator->secondNodeNr)
                        targetNode = nodeIt;
                }
            }

          //  edgeTupelPointer parentEdgeTupel = childIterator->parentEdgeTupel; /* altes Tupel ist jetzt Parent-Tupel */

#ifdef DEBUG
            if (!startNode)
            {
                printf("Kein Startknoten\n");
            }
#endif
            edgeListElementPointer newEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));     /* Erzeuge neue Kante zum Einfügen in*/
            edgeListElementPointer newReverseEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));/* Graphdarstellung des Subgraphs*/
            newEdge->edgeLabel = childIterator->edgeValue;
            newEdge->edgeStartNode = startNode;
            newEdge->edgeTarget = targetNode;
            newEdge->nextEdgeListElement = startNode->firstEdge;
            startNode->firstEdge->previousEdgeListElement = newEdge;
            newEdge->previousEdgeListElement = NULL;
            newEdge->reverseEdge = newReverseEdge;
            newReverseEdge->edgeLabel = childIterator->edgeValue;
            newReverseEdge->edgeStartNode = targetNode;
            newReverseEdge->edgeTarget = startNode;
            newReverseEdge->nextEdgeListElement = targetNode->firstEdge;
            if (targetNode->firstEdge)
                targetNode->firstEdge->previousEdgeListElement = newReverseEdge;
            newReverseEdge->previousEdgeListElement = NULL;
            newReverseEdge->reverseEdge = newEdge;

            startNode->firstEdge = newEdge;
            targetNode->firstEdge = newReverseEdge;

            /****************************************************************/

            tempTupel = childIterator->nextEdgeTupel;
            dfsCode[currentSubgraphSize-1] = childIterator;
            if (minxxx(currentSubgraphSize))
            {
                boolean result = FALSE;
                result = subgraphMining(childIterator);
                if (result == TRUE)
                {
                    return TRUE;
                }
#ifdef SPACESAVER
                removeSupergraphList(childIterator);
                al.free(childIterator);
#endif
            }
            else
            {
                removeSupergraphList(childIterator);
                al.free(childIterator);
            }

            lastNodeOfSubgraph = secondLastNode;

            if (newEdge->previousEdgeListElement)   /* Entferne neueste Kante wieder aus Graphdarstellung des aktullen Subgraphen */
                newEdge->previousEdgeListElement->nextEdgeListElement = newEdge->nextEdgeListElement;
            else
                startNode->firstEdge = newEdge->nextEdgeListElement;
            if (newEdge->nextEdgeListElement)
                newEdge->nextEdgeListElement->previousEdgeListElement = newEdge->previousEdgeListElement;

            if (newReverseEdge->previousEdgeListElement)
                newReverseEdge->previousEdgeListElement->nextEdgeListElement = newReverseEdge->nextEdgeListElement;
            else
                targetNode->firstEdge = newReverseEdge->nextEdgeListElement;
            if (newReverseEdge->nextEdgeListElement)
                newReverseEdge->nextEdgeListElement->previousEdgeListElement = newReverseEdge->previousEdgeListElement;

            if (!targetNode->firstEdge)
            {
                secondLastNode->nextNode = NULL;
                al.free(targetNode);
            }
            al.free(newEdge);
            al.free(newReverseEdge);
            childIterator = tempTupel;
        }
        currentSubgraphSize = oldSubgraphsize;
        dfsCode[currentSubgraphSize-1] = NULL;
        return FALSE;
    }

    void findSubgraphOccurrences() /* finde alle Subgraph-Vorkommen in DB */
    {
        int i,j,k;

        /* Es k?nnen alle potentiellen fw2 Erweiterungen aus den rechten Siblings von currentEdgeTupel abgeleitet werden */
        /* Erleichtert sp?ter den Test auf G?ltigkeit einer fw2 extensions */

        edgeTupelPointer currentFw2;
//      if(!findOnlyPaths)
//      {
        edgeTupelPointer siblingIterator = currentEdgeTupel;

        if (siblingIterator->secondNodeNr < siblingIterator->firstNodeNr)          /* F?r backwardedges beginnen die fw2 Erweiterungen */
        {                                                                          /* erst bei den fw2 siblings */
            while (siblingIterator && siblingIterator->firstNodeNr == currentEdgeTupel->firstNodeNr)
            {
                siblingIterator = siblingIterator->nextEdgeTupel;
            }
        }

        int intersectionSize = 0;
        superGraphPointer superGraphIterator1 = NULL;
        superGraphPointer superGraphIterator2 = NULL;
        fw2ExtensionCount = 0;

        memset(fw2ExtensionCountArray,0,maxNodeCount*sizeof(int));
        memset(remainingFw2ExtensionsArray,0,maxNodeCount*sizeof(int));


        while (siblingIterator) /* Iteriere ?ber hinteren Teil der edgeTupelListe zum Erzeugen aller potentiellen fw2 Erweiterungen */
        {
            if (currentSubgraphSize == 1 && siblingIterator->firstNodeValue != currentEdgeTupel->firstNodeValue)
            {
                break;       /* Liste der h?ufigen 1edge-Graphen enth?lt alle h?ufigen Kanten ohne Aufteilung nach Label des  */
            }                 /* Startknoten. Es k?nnen aber nur Kanten mit gleichem Startknoten-Label gejoined werden   */

            superGraphIterator1 = currentEdgeTupel->superGraphList->firstSuperGraph;
            superGraphIterator2 = siblingIterator->superGraphList->firstSuperGraph;
            intersectionSize = 0;

            while (superGraphIterator1 && superGraphIterator2 && intersectionSize < minSup)
            {
                if (superGraphIterator1->superGraphAdressInDB->graphNr < superGraphIterator2->superGraphAdressInDB->graphNr)
                {
                    superGraphIterator1 = superGraphIterator1->nextSuperGraph;
                }
                else if (superGraphIterator1->superGraphAdressInDB->graphNr > superGraphIterator2->superGraphAdressInDB->graphNr)
                {
                    superGraphIterator2 = superGraphIterator2->nextSuperGraph;
                }
                else
                {
                    intersectionSize++;
                    superGraphIterator1 = superGraphIterator1->nextSuperGraph;
                    superGraphIterator2 = superGraphIterator2->nextSuperGraph;
                }
            }

            if (intersectionSize < minSup) /* Erweiterung zu selten, wird deswegen nicht in Tabelle der fw2 Erweiterungen aufgenommen */
            {
                siblingIterator = siblingIterator->nextEdgeTupel;
                continue;
            }

            i = nodeID2RightestPathPosition[siblingIterator->firstNodeNr];
            j = siblingIterator->secondNodeValue;
            k = siblingIterator->edgeValue;

            fw2ExtensionCount++;
            fw2ExtensionCountArray[i]++;

#ifdef DEBUG
            if (i<0)
            {
                fprintf(stderr, "%d %d, i = %d\n",siblingIterator->firstNodeNr,siblingIterator->secondNodeNr,i);
                fprintf(stderr, "fw2 extension not on rightest Path\n");
                throw g_span_error;;
            }
#endif

            fw2CandidateTable[i][j][k] = TRUE;
            siblingIterator = siblingIterator->nextEdgeTupel;
        }
        //}

        /**** Jetzt suchen eines Startknotens um aktuellen Graphen mit einem Supergraphen zu matchen ****/

        superGraph = NULL;
        superGraph = dfsCode[currentSubgraphSize-1]->superGraphList->firstSuperGraph;
        //#ifdef SAVE_EMBEDDINGS
        superGraphPointer parentSuperGraph = NULL;
        if (useEmbLists && currentSubgraphSize > hybridThreshold)
        {
            if (currentSubgraphSize > 1)
                parentSuperGraph = dfsCode[currentSubgraphSize-2]->superGraphList->firstSuperGraph;
            else
                parentSuperGraph = NULL;
        }
        //#endif
#ifdef OCC_COUNT
        boolean finished = FALSE;
#endif

        while (superGraph)                             /* Iteriere ?ber alle SuperGraphen des aktuellen Graphen in der DB */
        {
#ifdef DEBUG
            occInGraph = 0;
#endif
            currentGraph = superGraph->superGraphAdressInDB;         /* globale Variable */
            remainingFw2Extensions = fw2ExtensionCount;
            int l;
            for (l=0; l<currentEdgeTupel->lengthOfRightestPath; l++)
            {
                remainingFw2ExtensionsArray[l] = fw2ExtensionCountArray[l];
            }

            //#ifdef SAVE_EMBEDDINGS
            if (useEmbLists)
            {
                if (parentSuperGraph)
                {
                    while (superGraph->superGraphAdressInDB != parentSuperGraph->superGraphAdressInDB)
                    {
                        parentSuperGraph = parentSuperGraph->nextSuperGraph;
                    }
                    if (parentSuperGraph->firstMatchArray)
                    {
#ifdef CLOCK
                        startEnumEmb = clock();
#endif
                        enumEmbeddings(parentSuperGraph->firstMatchArray);
#ifdef CLOCK
                        stopEnumEmb = clock();
                        enumDur += (double) (stopEnumEmb-startEnumEmb);
#endif
                        superGraph = superGraph->nextSuperGraph;
                        continue;
                    }
                }
            }
            //#endif
#ifdef CLOCK
            startMatch = clock();
#endif
            graphNodePointer currentNode;
            //printf("nodeMapCount: %d\n",currentGraph->nodeMapCount);
            if (currentGraph->nodeMapCount > 0)
            {
                currentNode = currentGraph->firstNode;  /* Iteriere ?ber die Knoten jedes Graphen */
                while (currentNode)
                {
                    if ((dfsCode[0])->firstNodeValue < currentNode->vertexLabel) /* Neu: Sortierung der Knoten*/
                    {
                        break;
                    }
                    if (currentNode->smallestFragSizeForWhichNodeHasToBeConsideredAsStartNodeForEmbedding > maxNodeCount)
                    {
                        currentNode = currentNode->nextNode;
                        continue;
                    }

                    if ((dfsCode[0])->firstNodeValue == currentNode->vertexLabel) /* Startknoten gefunden */
                    {
                        int originalID = currentNode->vertexID;  /* Merken der urspr?nglichen ID des gematchten Knotens */
                        currentNode->vertexID = (dfsCode[0])->firstNodeNr;
                        //#ifdef SYMMETRY
                        biConnCompNr = -1;
                        //#endif
                        extendNodeSymm(currentNode, 0);
                        currentNode->vertexID = originalID;                        /* Wiedereherstellen der ?rspr?nglichen KnotenID */
                    }
                    currentNode = currentNode->nextNode; /* Bei R?ckgabewert FALSE, mu? weiter gesucht werden nach n?chstem Startknoten */
                }
            }
            else
            {
                currentNode = currentGraph->firstNode;  /* Iteriere ?ber die Knoten jedes Graphen */
                while (currentNode)
                {
                    if ((dfsCode[0])->firstNodeValue < currentNode->vertexLabel) /* Neu: Sortierung der Knoten*/
                    {
                        break;
                    }
                    if ((dfsCode[0])->firstNodeValue == currentNode->vertexLabel) /* Startknoten gefunden */
                    {
                        int originalID = currentNode->vertexID;  /* Merken der urspr?nglichen ID des gematchten Knotens */
                        currentNode->vertexID = (dfsCode[0])->firstNodeNr;
                        extendNode(currentNode, 0);
                        currentNode->vertexID = originalID;                        /* Wiedereherstellen der ?rspr?nglichen KnotenID */
                    }
                    currentNode = currentNode->nextNode; /* Bei R?ckgabewert FALSE, mu? weiter gesucht werden nach n?chstem Startknoten */
                }
            }

#ifdef CLOCK
            stopMatch = clock();
            matchDur += (double) (stopMatch-startMatch);
#endif

            superGraph = superGraph->nextSuperGraph;       /* Gehe zum n?chsten Supergraphen */
        }

        /* Erzeugen der edgeTupelListe der Kinder des aktuellen Subgraphen */

       // superGraphPointer supGrIt;
        edgeTupelPointer previousEdgeTupel = NULL;

        if (!(findOnlyPaths || findOnlyTrees))
        {
            for (i=0;i<currentEdgeTupel->lengthOfRightestPath-1;i++)
            {
                for (j=0;j<edgeLabelCount;j++)
                {
                    if (bwTable[i][j])
                    {
                        if (bwTable[i][j]->superGraphList->size >= minSup)
                        {
                            if (previousEdgeTupel)
                            {
                                previousEdgeTupel->nextEdgeTupel = bwTable[i][j];
                                bwTable[i][j]->previousEdgeTupel = previousEdgeTupel;
                            }
                            else
                            {
                                currentEdgeTupel->firstChildEdgeTupel = bwTable[i][j];
                            }
                            previousEdgeTupel = bwTable[i][j];
                        }
                        else
                        {
#ifdef DEBUG
                            unsuccessfulCandidateCount++;
#endif
                            removeSupergraphList(bwTable[i][j]);
                            al.free(bwTable[i][j]);
                        }
                        bwTable[i][j] = NULL;
                    }
                }
            }
        }
        for (j=0;j<edgeLabelCount;j++)
        {
            for (i=0;i<nodeLabelCount;i++)
            {
                if (fw1Table[i][j])
                {
                    if (fw1Table[i][j]->superGraphList->size >= minSup)
                    {
                        if (previousEdgeTupel)
                        {
                            previousEdgeTupel->nextEdgeTupel = fw1Table[i][j];
                            fw1Table[i][j]->previousEdgeTupel = previousEdgeTupel;
                        }
                        else
                        {
                            currentEdgeTupel->firstChildEdgeTupel = fw1Table[i][j];
                        }
                        previousEdgeTupel = fw1Table[i][j];
                    }
                    else
                    {
#ifdef DEBUG
                        unsuccessfulCandidateCount++;
#endif
                        removeSupergraphList(fw1Table[i][j]);
                        al.free(fw1Table[i][j]);
                    }
                    fw1Table[i][j] = NULL;
                }
            }
        }
//      if(!findOnlyPaths)
//      {
        for (i=currentEdgeTupel->lengthOfRightestPath-1; i>=0;i--)
        {
            for (k=0;k<edgeLabelCount;k++)
            {
                for (j=0;j<nodeLabelCount;j++)
                {
                    fw2CandidateTable[i][j][k] = FALSE;
                    currentFw2 = fw2Table[i][j][k];
                    if (currentFw2)
                    {
                        if (currentFw2->superGraphList->size >= minSup)
                        {
                            if (previousEdgeTupel)
                            {
                                previousEdgeTupel->nextEdgeTupel = currentFw2;
                                currentFw2->previousEdgeTupel = previousEdgeTupel;
                            }
                            else
                            {
                                currentEdgeTupel->firstChildEdgeTupel = currentFw2;
                            }
                            previousEdgeTupel = currentFw2;
                        }
                        else
                        {
#ifdef DEBUG
                            unsuccessfulCandidateCount++;
#endif
                            removeSupergraphList(currentFw2);
                            al.free(currentFw2);
                        }
                        fw2Table[i][j][k] = NULL;
                    }
                }
            }
        }
//      }
        return;
    }

    /* Finde Rest des Subgraphen, nachdem mind. 1 Knoten bereits gefunden wurde */
    void extendNode(graphNodePointer node, int i)
    {
        int edgeValue = dfsCode[i]->edgeValue;
        int secondNodeValue = dfsCode[i]->secondNodeValue;
        int secondNodeNr = dfsCode[i]->secondNodeNr;
        int firstNodeNr = dfsCode[i]->firstNodeNr;
        int originalID;
        edgeListElementPointer edgeIt = node->firstEdge;

        while (edgeIt)
        {
            if (edgeIt->visited)
            {
                edgeIt = edgeIt->nextEdgeListElement;
                continue;
            }
            if (edgeIt->edgeLabel != edgeValue || edgeIt->edgeTarget->vertexLabel != secondNodeValue) /* das ist schneller als die */
            {                                                                                         /* Sortierung zu verwenden   */
                edgeIt = edgeIt->nextEdgeListElement;
                continue;
            }

            if (findOnlyPaths || findOnlyTrees)
            {
                if (secondNodeNr < firstNodeNr)
                {
                    edgeIt = edgeIt->nextEdgeListElement;
                    continue;
                }
            }
            if (secondNodeNr < firstNodeNr && edgeIt->edgeTarget->vertexID == secondNodeNr) /* bw edge erfolgreich gematcht */
            {
                edgeMatchList[i] = edgeIt;                     /* F?ge Kante in edgeMatchList ein */
                edgeIt->visited = TRUE;
                edgeIt->reverseEdge->visited = TRUE;

                if (i+1 < currentSubgraphSize) /* Wenn es noch weitere Kanten zu matchen gilt, rekursiver Aufruf der Funktion */
                {
                    if ((dfsCode[i+1])->firstOccOfStartNode == i+1)
                        extendNode(edgeIt->edgeStartNode, i+1);
                    else
                        extendNode(edgeMatchList[(dfsCode[i+1])->firstOccOfStartNode]->edgeStartNode, i+1);
                }
                else
                {
#ifdef OCC_COUNT
                    occInGraph++;
#endif
                    generatePotentialChildren(); /* sonst: Bestimme alle Kinder des Subgraphen in diesem Graphen */
                }
                edgeIt->visited = FALSE;
                edgeIt->reverseEdge->visited = FALSE;
            }
            else if (secondNodeNr > firstNodeNr && edgeIt->edgeTarget->vertexID < 0) /* fw Kante erfolgreich gematcht */
            {
                edgeMatchList[i] = edgeIt;
                edgeIt->visited = TRUE;
                edgeIt->reverseEdge->visited = TRUE;
                originalID = edgeIt->edgeTarget->vertexID;
                edgeIt->edgeTarget->vertexID = secondNodeNr;

                if (i+1 < currentSubgraphSize) /* Wenn es noch weitere Kanten zu matchen gilt: */
                {
                    if ((dfsCode[i+1])->firstOccOfStartNode == i+1)
                    {
                        extendNode(edgeIt->edgeTarget, i+1);
                    }
                    else
                        extendNode(edgeMatchList[(dfsCode[i+1])->firstOccOfStartNode]->edgeStartNode, i+1);
                }
                else
                {
#ifdef OCC_COUNT
                    occInGraph++;
#endif
                    generatePotentialChildren(); /* Bestimme alle Kinder des Subgraphen in diesem Graphen */
                }
                edgeIt->edgeTarget->vertexID = originalID;
                edgeIt->visited = FALSE;
                edgeIt->reverseEdge->visited = FALSE;
            }
            edgeIt = edgeIt->nextEdgeListElement;
        }
    }

    void extendNodeSymm(graphNodePointer node, int i)
    {
        int edgeValue = dfsCode[i]->edgeValue;
        int secondNodeValue = dfsCode[i]->secondNodeValue;
        int secondNodeNr = dfsCode[i]->secondNodeNr;
        int firstNodeNr = dfsCode[i]->firstNodeNr;
        int originalID;

        edgeListElementPointer edgeIt = node->firstEdge;
        //#ifdef SYMMETRY
        int altStartNode = 0;
        //#endif

        while (edgeIt)
        {
            if (edgeIt->visited)
            {
                edgeIt = edgeIt->nextEdgeListElement;
                continue;
            }

            if (edgeIt->edgeLabel != edgeValue || edgeIt->edgeTarget->vertexLabel != secondNodeValue) /* das ist schneller als die */
            {                                                                                         /* Sortierung zu verwenden   */
                edgeIt = edgeIt->nextEdgeListElement;
                continue;
            }

            if (secondNodeNr < firstNodeNr && edgeIt->edgeTarget->vertexID == secondNodeNr) /* bw edge erfolgreich gematcht */
            {
                edgeMatchList[i] = edgeIt;                     /* F?ge Kante in edgeMatchList ein */
                edgeIt->visited = TRUE;
                edgeIt->reverseEdge->visited = TRUE;

                if (i+1 < currentSubgraphSize) /* Wenn es noch weitere Kanten zu matchen gilt, rekursiver Aufruf der Funktion */
                {
                    //#ifdef SYMMETRY
                    biConnCompNr = edgeIt->biconnCompNr;
                    //#endif
                    if ((dfsCode[i+1])->firstOccOfStartNode == i+1)
                        extendNodeSymm(edgeIt->edgeStartNode, i+1);
                    else
                        extendNodeSymm(edgeMatchList[(dfsCode[i+1])->firstOccOfStartNode]->edgeStartNode, i+1);
                }
                else
                {
#ifdef OCC_COUNT
                    occInGraph++;
#endif
                    generatePotentialChildren(); /* sonst: Bestimme alle Kinder des Subgraphen in diesem Graphen */
                }
                edgeIt->visited = FALSE;
                edgeIt->reverseEdge->visited = FALSE;
            }
            else if (secondNodeNr > firstNodeNr && edgeIt->edgeTarget->vertexID < 0) /* fw Kante erfolgreich gematcht */
            {
                //#ifdef SYMMETRY
                if (biConnCompNr != edgeIt->biconnCompNr)
                {
                    if (edgeIt->edgeTarget->altStartNode == altStartNode)
                    {
#ifdef DEBUG
                        if (edgeIt->edgeTarget->firstEdge->nextEdgeListElement != NULL)
                        {
                            forkCount++;
                        }
                        else
                            forkCount2++;
#endif

                        if (!edgeIt->isNotEquivalent)
                        {
                            edgeIt = edgeIt->nextEdgeListElement;
                            continue;
                        }
                    }
                    else
                    {
                        altStartNode = edgeIt->edgeTarget->altStartNode;
                    }
                }
                //#endif

                edgeMatchList[i] = edgeIt;
                edgeIt->visited = TRUE;
                edgeIt->reverseEdge->visited = TRUE;

                originalID = edgeIt->edgeTarget->vertexID;
                edgeIt->edgeTarget->vertexID = secondNodeNr;

                if (i+1 < currentSubgraphSize) /* Wenn es noch weitere Kanten zu matchen gilt: */
                {
                    //#ifdef SYMMETRY
                    biConnCompNr = edgeIt->biconnCompNr;
                    //#endif
                    if ((dfsCode[i+1])->firstOccOfStartNode == i+1)
                    {
                        extendNodeSymm(edgeIt->edgeTarget, i+1);
                    }
                    else
                        extendNodeSymm(edgeMatchList[(dfsCode[i+1])->firstOccOfStartNode]->edgeStartNode, i+1);
                }
                else
                {
#ifdef OCC_COUNT
                    occInGraph++;
#endif
                    generatePotentialChildren(); /* Bestimme alle Kinder des Subgraphen in diesem Graphen */
                }
                edgeIt->edgeTarget->vertexID = originalID;
                edgeIt->visited = FALSE;
                edgeIt->reverseEdge->visited = FALSE;
            }
            edgeIt = edgeIt->nextEdgeListElement;
        }
    }

    void generatePotentialChildren()
    {
        int i;
        //#ifdef SAVE_EMBEDDINGS
        if (useEmbLists && currentSubgraphSize >= hybridThreshold)
        {
            edgeListElementPointer *emlCopy = (edgeListElementPointer *)al.malloc(currentSubgraphSize*sizeof(edgeListElementPointer));
            for (i=0;i<currentSubgraphSize;i++)
            {
                emlCopy[i] = edgeMatchList[i];
            }
            matchEdgeListElementPointer edgeMatchListElement = NULL;
            edgeMatchListElement = (matchEdgeListElementPointer)al.malloc(sizeof(matchEdgeListElement));
            edgeMatchListElement->arraySize = currentSubgraphSize;
            edgeMatchListElement->matchArray = emlCopy;
            edgeMatchListElement->nextMatchArray = superGraph->firstMatchArray;
            superGraph->firstMatchArray = edgeMatchListElement;
        }
        //#endif

        edgeListElementPointer edgeExtension = NULL; /* Kantenliste des ersten Ausgangsknotens f?r Extensions (mu? neuester Knoten sein!) */
        //edgeTupelPointer lastForwardEdge = NULL;
        int l;

        if ((dfsCode[currentSubgraphSize-1])->firstNodeNr > (dfsCode[currentSubgraphSize-1])->secondNodeNr) /* wenn letzte Extension bwEdge*/
        {
            edgeExtension = (edgeMatchList[currentSubgraphSize-1])->edgeStartNode->firstEdge;  /*  ...ist edgeStartNode der neueste Knoten */
        }
        else
        {
            edgeExtension = (edgeMatchList[currentSubgraphSize-1])->edgeTarget->firstEdge;   /* ... sonst ist edgeTarget neuester Knoten*/
        }
        //printf("->  %d %d %d %d %d\n",edgeExtension->edgeStartNode->vertexID,edgeExtension->edgeTarget->vertexID, edgeExtension->edgeStartNode->vertexLabel, edgeExtension->edgeLabel, edgeExtension->edgeTarget->vertexLabel);
        //printf("graphNr: %d\n", currentGraph->graphNr);
        int j;//,k;

        while (edgeExtension)  /* Durchlaufe alle Kanten dieses Knotens, teste ob sie als Extension taugen */
        {
            if (edgeExtension->visited)
            {
                edgeExtension = edgeExtension->nextEdgeListElement;
                continue;
            }
            i = edgeExtension->edgeTarget->vertexID;
            j = edgeExtension->edgeLabel;

            if (i >= 0) /* Wenn neue Extension eine backwardedge ist, teste ob sie schon in bwTable ist */
            {
                if (findOnlyTrees || findOnlyPaths)
                {
                    edgeExtension = edgeExtension->nextEdgeListElement;
                    continue;
                }
                if (nodeID2RightestPathPosition[i] <0) /* dann liegt der Zielknoten der bw edge nicht auf rechtestem Pfad*/
                {
                    edgeExtension = edgeExtension->nextEdgeListElement;
                    continue;
                }
                if (bwTable[nodeID2RightestPathPosition[i]][j] != NULL)
                {
                    insertInSuperGraphList(bwTable[nodeID2RightestPathPosition[i]][j]->superGraphList, currentGraph);
                    edgeExtension = edgeExtension->nextEdgeListElement;
                    continue;
                }
                else  /* bw Kannte ist noch nicht in der Tabelle */
                {
                    if (currentEdgeTupel->firstNodeNr > currentEdgeTupel->secondNodeNr) /* wenn auch vorige Extension backwarde edge war ... */
                    {
                        if (i <= edgeMatchList[currentSubgraphSize-1]->edgeTarget->vertexID) /* ... und neue bwEdge kleiner als vorige ... */
                        {
                            edgeExtension = edgeExtension->nextEdgeListElement;            /* ... dann ist die neue bwEdge ung?ltig */
                            continue;
                        }
                    }
                    ETP compareEdge = dfsCode[rightestPathPosition2edgeTupelNr[nodeID2RightestPathPosition[i]]]; /* backwardedge mu?     */
                    if (compareEdge->edgeValue > j)                                                              /* property 2 erf?llen: */
                    {                                                                         /* Vom Zielknoten der backwardedge darf    */
                        edgeExtension = edgeExtension->nextEdgeListElement;                   /* keine gr??ere Kante ausgehen im Subgraph*/
                        continue;
                    }
                    else
                    {
                        if (compareEdge->edgeValue == j && compareEdge->secondNodeValue > edgeExtension->edgeStartNode->vertexLabel)
                        {
                            edgeExtension = edgeExtension->nextEdgeListElement;
                            continue;
                        }
                        else
                        {
                            insertInBwTable(edgeExtension);
                        }
                    }
                }
            }
            else  /* Kante ist fw1 erweiterung */
            {
                int extensionTargetLabel = edgeExtension->edgeTarget->vertexLabel;
                if (fw1Table[extensionTargetLabel][edgeExtension->edgeLabel] != NULL)
                {
#ifdef DEBUG
                    if (!fw1Table[extensionTargetLabel][edgeExtension->edgeLabel]->superGraphList->lastSuperGraph)
                    {
                        printf("leere Liste\n");
                    }
#endif
                    insertInSuperGraphList(fw1Table[extensionTargetLabel][edgeExtension->edgeLabel]->superGraphList, currentGraph);
                }
                else
                {
                    int originalID = edgeExtension->edgeTarget->vertexID;
                    edgeExtension->edgeTarget->vertexID = std::max(currentEdgeTupel->secondNodeNr,currentEdgeTupel->firstNodeNr)+1;
                    insertInFw1Table(edgeExtension);
                    edgeExtension->edgeTarget->vertexID = originalID;
                }
                edgeExtension = edgeExtension->nextEdgeListElement;
                continue;
            }
            edgeExtension = edgeExtension->nextEdgeListElement;
        }

        edgeTupelPointer correspondingTupel = NULL;

        if (remainingFw2Extensions == 0) /* Wenn bereits alle m?glichen fw2Extensions gefunden wurden, mu? man hier nicht weiter suchen */
        {                               /* Dann ist aber f?r alle fw2Extensions in diesem Supergrah der Wert ->occ nicht mehr verl?sslich */
            return;
        }

        /*********** Finde Extensions f?r restliche Knoten ****************/

        for (l=currentEdgeTupel->lengthOfRightestPath-1; l>=0; l--) /* Durchlaufe alle Kanten des rechtesten Pfades und teste*/
        {                                                             /* alle Extensions der Startknoten als Kandidaten f?r */
            if (remainingFw2ExtensionsArray[l] == 0)
            {
                continue;
            }
            if (findOnlyPaths && (l!=0 || currentEdgeTupel->lengthOfRightestPath != currentSubgraphSize))
                continue;

            edgeExtension = (edgeMatchList[rightestPathPosition2edgeTupelNr[l]])->edgeStartNode->firstEdge; /*fw2 extends */
            while (edgeExtension)
            {
                if (edgeExtension->visited)
                {
                    edgeExtension = edgeExtension->nextEdgeListElement;
                    continue;
                }
                if (edgeExtension->edgeTarget->vertexID >= 0)   /* Zielknoten der Extension liegt bereits im Subgraphen */
                {
                    edgeExtension = edgeExtension->nextEdgeListElement;
                    continue;
                }

                i = edgeExtension->edgeTarget->vertexLabel;
                j = edgeExtension->edgeLabel;
                if (fw2CandidateTable[l][i][j])
                {
                    correspondingTupel = fw2Table[l][i][j];
                    if (!correspondingTupel)
                    {
                        remainingFw2Extensions--;
                        remainingFw2ExtensionsArray[l]--;
                        fw2Table[l][i][j] = insertInFw2Table(edgeExtension, l);
                    }
                    insertInSuperGraphList(fw2Table[l][i][j]->superGraphList, currentGraph);
                }
                edgeExtension = edgeExtension->nextEdgeListElement;
            }
        }

    }

    /************************************************************************************/

    edgeTupelPointer insertInFw2Table(edgeListElementPointer edgeExtension, int l)
    {
        edgeTupelPointer currentFw2 = (edgeTupelPointer)al.gc_malloc(sizeof(edgeTupel));
        currentFw2->firstNodeNr = edgeExtension->edgeStartNode->vertexID;
        currentFw2->secondNodeNr = std::max(currentEdgeTupel->secondNodeNr,currentEdgeTupel->firstNodeNr)+1;
        currentFw2->firstNodeValue = edgeExtension->edgeStartNode->vertexLabel;
        currentFw2->edgeValue = edgeExtension->edgeLabel;
        currentFw2->secondNodeValue = edgeExtension->edgeTarget->vertexLabel;
        currentFw2->occurrences = 0;                        /* Wird sp?ter bestimmt, ist kleiner gleich intersectionSize */
        currentFw2->lengthOfRightestPath = l+1;
        currentFw2->longestPathSize = currentEdgeTupel->longestPathSize;

        currentFw2->nextEdgeTupel = NULL;
        currentFw2->previousEdgeTupel = NULL;
        currentFw2->firstChildEdgeTupel = NULL;
        currentFw2->parentEdgeTupel = currentEdgeTupel;
        currentFw2->firstOccOfStartNode = dfsCode[rightestPathPosition2edgeTupelNr[l]]->firstOccOfStartNode;

        superGraphListPointer newSuperGraphList;
        newSuperGraphList = (superGraphListPointer)al.gc_malloc(sizeof(superGraphList));
        newSuperGraphList->size = 0;
        newSuperGraphList->firstSuperGraph = NULL;
        newSuperGraphList->lastSuperGraph = NULL;
        currentFw2->superGraphList = newSuperGraphList;
        return currentFw2;
    }

    /********************************************************************************************************************************/

    void insertInBwTable(edgeListElementPointer edgeExtension)
    {
        int i = nodeID2RightestPathPosition[edgeExtension->edgeTarget->vertexID];
        int j = edgeExtension->edgeLabel;

#ifdef DEBUG
        if (bwTable[i][j] != NULL)
        {
            printf("%d   %d\n",edgeExtension->edgeTarget->vertexID,i);
            fprintf(stderr, "bw extension exists already!\n");
            throw g_span_error;;
        }
#endif

        edgeTupelPointer bwExt = (edgeTupelPointer)al.malloc(sizeof(edgeTupel));
        bwExt->firstNodeNr = edgeExtension->edgeStartNode->vertexID;
        bwExt->secondNodeNr = edgeExtension->edgeTarget->vertexID;
        bwExt->firstNodeValue = edgeExtension->edgeStartNode->vertexLabel;
        bwExt->edgeValue = edgeExtension->edgeLabel;
        bwExt->secondNodeValue = edgeExtension->edgeTarget->vertexLabel;
        bwExt->occurrences = 0;                        /* Wird sp?ter bestimmt, ist kleiner gleich intersectionSize */
        bwExt->lengthOfRightestPath = currentEdgeTupel->lengthOfRightestPath;
        bwExt->longestPathSize = currentEdgeTupel->longestPathSize;
        bwExt->nextEdgeTupel = NULL;
        bwExt->previousEdgeTupel = NULL;
        bwExt->firstChildEdgeTupel = NULL;
        bwExt->parentEdgeTupel = currentEdgeTupel;
        bwExt->firstOccOfStartNode = currentSubgraphSize;

        superGraphListPointer newSuperGraphList;
        newSuperGraphList = (superGraphListPointer)al.malloc(sizeof(superGraphList));
        newSuperGraphList->size = 0;
        newSuperGraphList->firstSuperGraph = NULL;
        newSuperGraphList->lastSuperGraph = NULL;

        bwExt->superGraphList = newSuperGraphList;
        insertInSuperGraphList(bwExt->superGraphList, currentGraph);
        bwTable[i][j] = bwExt;
    }

    void insertInFw1Table(edgeListElementPointer edgeExtension)
    {
        int i = edgeExtension->edgeTarget->vertexLabel;
        int j = edgeExtension->edgeLabel;

#ifdef DEBUG
        if (fw1Table[i][j] != NULL)
        {
            fprintf(stderr, "fw1 extension exists already!\n");
            throw g_span_error;;
        }
#endif

        fw1Table[i][j] = (edgeTupelPointer)al.gc_malloc(sizeof(edgeTupel));
        fw1Table[i][j]->firstNodeNr = edgeExtension->edgeStartNode->vertexID;
        fw1Table[i][j]->secondNodeNr = edgeExtension->edgeTarget->vertexID;

#ifdef DEBUG
        if (edgeExtension->edgeTarget->vertexID < 0)
        {
            fprintf(stderr, "negative match edge\n");
            throw g_span_error;;
        }
#endif

        fw1Table[i][j]->firstNodeValue = edgeExtension->edgeStartNode->vertexLabel;
        fw1Table[i][j]->edgeValue = edgeExtension->edgeLabel;
        fw1Table[i][j]->secondNodeValue = edgeExtension->edgeTarget->vertexLabel;
        fw1Table[i][j]->occurrences = 0;                        /* Wird sp?ter bestimmt, ist kleiner gleich intersectionSize */
        fw1Table[i][j]->lengthOfRightestPath = currentEdgeTupel->lengthOfRightestPath+1;
        fw1Table[i][j]->longestPathSize = std::max(currentEdgeTupel->longestPathSize,fw1Table[i][j]->lengthOfRightestPath);
        fw1Table[i][j]->nextEdgeTupel = NULL;
        fw1Table[i][j]->previousEdgeTupel = NULL;
        fw1Table[i][j]->firstChildEdgeTupel = NULL;
        fw1Table[i][j]->parentEdgeTupel = currentEdgeTupel;
        fw1Table[i][j]->firstOccOfStartNode = currentSubgraphSize;

        superGraphListPointer newSuperGraphList;
        newSuperGraphList = (superGraphListPointer)al.gc_malloc(sizeof(superGraphList));
        newSuperGraphList->size = 0;
        newSuperGraphList->firstSuperGraph = NULL;
        newSuperGraphList->lastSuperGraph = NULL;

        fw1Table[i][j]->superGraphList = newSuperGraphList;

        insertInSuperGraphList(fw1Table[i][j]->superGraphList, currentGraph);
    }
    /**********************************************/
    edgeListElementPointer *copyEdgeMatchList()
    {
        int i;
        edgeListElementPointer *emlCopy = (edgeListElementPointer *)al.malloc(currentSubgraphSize*sizeof(edgeListElementPointer));
        for (i=0;i<currentSubgraphSize;i++)
        {
            emlCopy[i] = edgeMatchList[i];
        }
        return emlCopy;
    }

    void insertInMatchEdgeList(edgeListElementPointer *emlCopy)
    {
        matchEdgeListElementPointer edgeMatchListElement = NULL;
        edgeMatchListElement = (matchEdgeListElementPointer)al.malloc(sizeof(matchEdgeListElement));
        edgeMatchListElement->arraySize = currentSubgraphSize;
        edgeMatchListElement->matchArray = emlCopy;
        edgeMatchListElement->nextMatchArray = superGraph->firstMatchArray;
        superGraph->firstMatchArray = edgeMatchListElement;
    }

    void enumEmbeddings(matchEdgeListElementPointer matchListElement)
    {
        int i;
        graphNodePointer secondLastNode;
        edgeListElementPointer *matchArray;
        edgeListElementPointer edgeIt;
        int originalNodeIDs[currentSubgraphSize+1];
        edgeListElementPointer matchArray_i;
        edgeTupelPointer dfsCode_i;

        while (matchListElement)
        {
            matchArray = matchListElement->matchArray;
            originalNodeIDs[0] = matchArray[0]->edgeStartNode->vertexID;
            matchArray[0]->edgeStartNode->vertexID = 0;
            for (i=0;i<currentSubgraphSize-1;i++)
            {
                matchArray_i = matchArray[i];
                dfsCode_i = dfsCode[i];
                if (dfsCode_i->secondNodeNr > dfsCode_i->firstNodeNr)
                {
                    originalNodeIDs[dfsCode_i->secondNodeNr] = matchArray_i->edgeTarget->vertexID;
                    matchArray_i->edgeTarget->vertexID = dfsCode_i->secondNodeNr;
                }
                edgeMatchList[i]=matchArray_i;
                matchArray_i->visited = TRUE;
                matchArray_i->reverseEdge->visited = TRUE;
            }
            if (dfsCode[currentSubgraphSize-1]->firstNodeNr == dfsCode[currentSubgraphSize-2]->secondNodeNr)
                secondLastNode = matchArray[currentSubgraphSize-2]->edgeTarget;
            else
            {
                if (dfsCode[currentSubgraphSize-1]->firstNodeNr == dfsCode[currentSubgraphSize-2]->firstNodeNr)
                    secondLastNode = matchArray[currentSubgraphSize-2]->edgeStartNode;
                else
                    secondLastNode = matchArray[dfsCode[currentSubgraphSize-1]->firstOccOfStartNode]->edgeStartNode;
            }

            if (currentGraph->nodeMapCount > 0)
            {
                //#ifdef SYMMETRY
                biConnCompNr = matchArray[currentSubgraphSize-2]->biconnCompNr;
                //#endif
                extendNodeSymm(secondLastNode, currentSubgraphSize-1);
            }
            else
                extendNode(secondLastNode, currentSubgraphSize-1);

            edgeIt = secondLastNode->firstEdge;

            matchArray[0]->edgeStartNode->vertexID = originalNodeIDs[0];
            for (i=0;i<currentSubgraphSize-1;i++)
            {
                matchArray_i = matchArray[i];
                dfsCode_i = dfsCode[i];
                if (dfsCode_i->secondNodeNr > dfsCode_i->firstNodeNr)
                {
                    matchArray_i->edgeTarget->vertexID = originalNodeIDs[dfsCode_i->secondNodeNr];
                }
                matchArray_i->visited = FALSE;
                matchArray_i->reverseEdge->visited = FALSE;
            }
            matchListElement = matchListElement->nextMatchArray;
        }
    }

    /********************************************/
    void removeSupergraphList(edgeTupelPointer tupel)
    {
        superGraphPointer listIterator = tupel->superGraphList->firstSuperGraph;
        superGraphPointer tempIterator = NULL;
        matchEdgeListElementPointer matchArrayIt = NULL;
        matchEdgeListElementPointer tempMatchArrayIt = NULL;
        while (listIterator)
        {
            matchArrayIt = listIterator->firstMatchArray;
            while (matchArrayIt)
            {
                tempMatchArrayIt = matchArrayIt;
                matchArrayIt = matchArrayIt->nextMatchArray;
                al.free(tempMatchArrayIt->matchArray);
                al.free(tempMatchArrayIt);
            }
            tempIterator = listIterator;
            listIterator = listIterator->nextSuperGraph;
            al.free(tempIterator);
        }
        al.free(tupel->superGraphList);
    }

    void insertInSuperGraphList(superGraphListPointer superGraphList, graphPointer newSuperGraph)
    {
#ifdef DEBUG
        if (!superGraphList)
        {
            fprintf(stderr, "superGraphList undefined\n");
            throw g_span_error;;
        }
#endif

        if (superGraphList->lastSuperGraph) /* Wenn es schon Graphen in der Liste gibt, mu? ?berpr?ft werden, da? der neue Graph nicht */
        {
            if (superGraphList->lastSuperGraph->superGraphAdressInDB->graphNr == newSuperGraph->graphNr) /* bereits in der Liste ist */
            {
                superGraphList->lastSuperGraph->occ++;
                return;
            }
        }
        /* Wenn man an diese Position gelangt ist, mu? entweder die Liste leer sein oder der neue Graph ist noch nicht in der Liste */

        superGraphPointer temp;     /* Das neue Element der SuperGraphListe */
        temp = (superGraphPointer)al.gc_malloc(sizeof(superGraphListElement));
        temp->superGraphAdressInDB = newSuperGraph;
        temp->occ = 1;
        temp->nextSuperGraph = NULL;
        temp->firstMatchArray = NULL;
#ifdef DEBUG
        if (!temp)
            fprintf(stderr, "out of memory\n");
#endif

        if (!superGraphList->firstSuperGraph)               /*Falls SuperGraphListe noch leer,... */
        {
            superGraphList->firstSuperGraph = temp;            /* Pointer auf ersten Graphen der SuperGraphListe wird gesetzt */
            superGraphList->lastSuperGraph = temp;             /* Pointer auf letzen Graph der Supergraphliste wird aktualisiert */
            (superGraphList->size)++;
        }
        else
        {
            superGraphList->lastSuperGraph->nextSuperGraph = temp;   /* Sonst h?nge neues Element an das Ende der SuperGraphListe */
            superGraphList->lastSuperGraph = temp;            /* Pointer auf letzen Graph der Supergraphliste wird aktualisiert */
            superGraphList->size++;
        }
    }

    void tempRemoveEdge(edgeListElementPointer edge)
    {
        edgeListElementPointer reverseEdge = edge->reverseEdge;
        if (edge->previousEdgeListElement)
            edge->previousEdgeListElement->nextEdgeListElement = edge->nextEdgeListElement;
        else
            edge->edgeStartNode->firstEdge = edge->nextEdgeListElement;
        if (edge->nextEdgeListElement)
            edge->nextEdgeListElement->previousEdgeListElement = edge->previousEdgeListElement;
        if (reverseEdge->previousEdgeListElement)
            reverseEdge->previousEdgeListElement->nextEdgeListElement =  reverseEdge->nextEdgeListElement;
        else
            reverseEdge->edgeStartNode->firstEdge = reverseEdge->nextEdgeListElement;
        if (reverseEdge->nextEdgeListElement)
            reverseEdge->nextEdgeListElement->previousEdgeListElement = reverseEdge->previousEdgeListElement;
    }

    void removeEdgeFromDB(graphDatabasePointer graphDBpointer, edgeTupelPointer k)
    {
        superGraphPointer l = k->superGraphList->firstSuperGraph;     /*Zeigt auf das aktuell betrachtete Element der SuperGraphListe */
        superGraphPointer previousSuperGraph = NULL;    /* zum Testen es ob noch Graphen vor dem aktuellen Graphen gibt */
        superGraphPointer tempGraph = NULL;       /* zum Zwischenspeichern, falls ein (leerer) Graph gel?scht wird */
        graphNodePointer m = NULL;
        graphNodePointer targetNode = NULL;
        graphNodePointer tempNode;                                    /* zum Zwischenspeichern, falls Knoten gel?scht wird */
        graphNodePointer previousNode = NULL;
        edgeListElementPointer n;
        edgeListElementPointer tempEdge = NULL;       /* zum Zwischenspeichern, falls eine Kante gel?scht wird */

        while (l)          /* Iteriere ?ber die Graphen der SuperGraphListe */
        {
            m = l->superGraphAdressInDB->firstNode;
            previousNode = NULL;
            tempNode = NULL;

#ifdef DEBUG
            if (!l->superGraphAdressInDB->firstNode)
            {
                printf("leerer graph nicht entfernt\n");
                throw g_span_error;;
            }
#endif
            while (m)                          /*Iterieren ?ber die Knoten des Graphen */
            {
                if (m->vertexLabel == k->firstNodeValue)       /*Nur falls KnotenLabel gleich sind, kann Kante gefunden werden */
                {
                    n = m->firstEdge;      /* zum Iterieren ?ber die Kanten n, die von Knoten m ausgehen*/
                    tempEdge = NULL;       /* zum Zwischenspeichern, falls eine Kante gel?scht wird */

                    while (n)   /* Iterieren ?ber die Kanten n, die von Knoten m ausgehen*/
                    {
                        targetNode = n->edgeTarget;
                        if (n->edgeLabel == k->edgeValue && n->edgeTarget->vertexLabel == k->secondNodeValue) /* Kante gefunden? */
                        {
                            tempRemoveEdge(n);
                            al.free(n->reverseEdge);
                            tempEdge = n;
                            n = n->nextEdgeListElement;
                            al.free(tempEdge);
                            continue;
                        }
                        n = n->nextEdgeListElement;
                    }
                }

                previousNode = m;
                m = m->nextNode;
            }

            m = l->superGraphAdressInDB->firstNode;
            previousNode = NULL;
            tempNode = NULL;

            while (m)                          /*Iterieren ?ber die Knoten des Graphen */
            {
                if (!m->firstEdge)
                {
                    if (previousNode)
                        previousNode->nextNode = m->nextNode;
                    else
                        l->superGraphAdressInDB->firstNode = m->nextNode;
                    tempNode = m;
                    m = m->nextNode;
                    al.free(tempNode);
                    continue;
                }
                previousNode  = m;
                m = m->nextNode;
            }

            tempGraph = l -> nextSuperGraph;

            if (!(l->superGraphAdressInDB->firstNode))/* Falls alle Knoten des Graphen l gel?scht wurden, soll auch l aus DB gel?scht werden */
            {
                (graphDBpointer->numberOfGraphsInDB)--;
                if (previousSuperGraph)
                    previousSuperGraph->nextSuperGraph = l->nextSuperGraph;
                else
                    k->superGraphList->firstSuperGraph = l->nextSuperGraph;

                tempGraph = l -> nextSuperGraph;
                al.free(l);
#ifdef DEBUG
                removedGraphs++;
#endif                                      /* L?sche Graph in SuperGraphListe */
                l = tempGraph;   /* gehe zum n?chsten Graphen */
            }
            else       /* Wenn der Graph nicht gel?scht werden soll (weil er nicht leer ist) ... */
            {
                previousSuperGraph = l;     /* ... merke neuen Vorg?nger Graphen ... */
                l  = l -> nextSuperGraph;   /* ... und gehe zum n?chsten Graphen */
            }
        }
    }

    void printUsage()
    {
        fprintf(stderr,"\nUsage:\n\n");
        fprintf(stderr,"./gSpan [Options] <minSup> <inputfile> (<outputfile>)\n");
        fprintf(stderr,"     -e   : Use embedding lists\n");
        fprintf(stderr,"     -s   : Use symmetries\n");
        fprintf(stderr,"     -a   : Relabel in ascending frequency (Default: descending frequency)\n");
        fprintf(stderr,"     -m i : Restrict search to fragments with maximum i edges\n");
        fprintf(stderr,"     -p   : Restrict search to linear fragments\n");
        fprintf(stderr,"     -t   : Restrict search to acyclic fragments\n");
        fprintf(stderr,"     -h j : Use embedding lists only for fragments of size j or larger\n");
    }


    std::vector<molecule> &get_backbones() {
        return m_backbones;
    }

    g_span() :
            end_time(0.0),
            matchedNodeCount(0),
            bfsCode(NULL),
            previousEdge(NULL),
            nextEdge(NULL),
            viererkreisCount(0),
            mapCount(0),
            currentGraph(NULL),
            currentEdgeTupel(NULL),
            currentSubgraphSize(0),
            minsizeSubgraphSize(0),
            maxSubgraphSize(0),
            freqSubgraphCount(0),
            oldFreqSubgraphCount(0),
            nrFrags(0),
            minBB(0),
            m_search_second(false),
            fw2ExtensionCount(0),
            superGraph(NULL),
            firstNodeOfSubgraph(NULL),
            lastNodeOfSubgraph(NULL),
            maxFragSize(-1),
            useSymm(FALSE),
            useAscFreqOrder(FALSE),
            useEmbLists(FALSE),
            hybridThreshold(-1),
            findOnlyTrees(FALSE),
            findOnlyPaths(FALSE),
            minSup(-1),
            createOutput(TRUE),
            filename(NULL),
            outputfile(NULL),
            unconnected(0),         /* Anzahl der kantenlosen Knoten, die entfernt wurden */
            maxNodeCount(0),   /* Maximalanzahl von Knoten in einem Graphen der DB */
            maxEdgeCount(0),
            maxNodeDegree(0),
            freedGraphs(0),  /* Zählt wieviele leere Graphen aus der DB gelöscht wurden */

            iterationsOverDB(0),
            freqOneEdgeGraphs(NULL)
            
    {
        std::fill( edgeLabelFrequency, edgeLabelFrequency+MAX_EDGE_TYPES, 0);
        std::fill( nodeLabelFrequency, nodeLabelFrequency+MAX_NODE_TYPES, 0);
        
    }
    bool notrun;
    int m_runid;
    
//     boolean mainis(std::istream &is, int minsup_, double threshold_, int run, double timeout)
//     {
//         
//         if( !false ) {
//             useSymm = TRUE;
//             useAscFreqOrder = TRUE;
//         }
//         
// #if 0
//         if (argc < 3)
//         {
//             printUsage();
//             throw g_span_error();
//         }
//         int i = 1;
//         while (i < argc-1)
//         {
//             if (argv[i][0] == '-')
//             {
//                 if (argv[i][1] == 'm')
//                 {
//                     i++;
//                     maxFragSize = atoi(argv[i]);
//                 }
//                 else if (argv[i][1] == 's')
//                 {
//                     useSymm = TRUE;
//                 }
//                 else if (argv[i][1] == 'a')
//                 {
//                     useAscFreqOrder = TRUE;
//                 }
//                 else if (argv[i][1] == 'e')
//                 {
//                     useEmbLists = TRUE;
//                 }
//                 else if (argv[i][1] == 'h')
//                 {
//                     i++;
//                     useEmbLists = TRUE;
//                     hybridThreshold = atoi(argv[i]);
//                 }
//                 else if (argv[i][1] == 't')
//                 {
//                     findOnlyTrees = TRUE;
//                 }
//                 else if (argv[i][1] == 'p')
//                 {
//                     findOnlyPaths = TRUE;
//                 }
//                 else
//                 {
//                     //fprintf(stderr,"Unknown option -%s\n\n",*argv[i]);
//                     printUsage();
//                     throw g_span_error();
//                 }
//             }
//             else
//             {
//                 break;
//             }
// 
//             i++;
//         }
// #endif
//         
//                 
//         minSup = minsup_;
//         threshold = threshold_;
//         
//         
//         if( timeout > 0.0 ) {
//         
//             end_time = gettime() + timeout;
//         }
//         
//         createOutput = true;
// //         printf( "run: %d %d %f %f\n", run, minSup, threshold, timeout );
//         
// //         if (argv[i])
// //         {
// //             minSup = atoi(argv[i]);
// //             if (argv[i+1])
// //             {
// //                 filename = argv[i+1];
// //                 if (argv[i+2])
// //                 {
// //                     threshold = atof(argv[i+2]);
// //                     createOutput = TRUE;
// //                     /*if(argv[i+3])
// //                     {
// //                             outputfile = argv[i+3];
// //                             createOutput = TRUE;
// //                     }*/
// //                 }
// //             }
// //             else
// //             {
// //                 printUsage();
// //                 throw g_span_error();
// //             }
// //         }
// //         else
// //         {
// //             printUsage();
// //             throw g_span_error();
// //         }
// 
// //      if(minSup <= 0)
// //      {
// //              fprintf(stderr, "<minSup> in not a positive integer\n");
// //              fprintf(stderr, "Usage: ./a.out <filename> <minSup> (<maxFragSize>)\n");
// //              exit(1);
// //      }
// //         printf( "filename: %s\n", filename );
// //         preprocessDB(filename);
//         preprocessDB(is);
//         
//         //printf("preprocessing finished\n");
// 
// //      #ifdef MAXFRAGSIZE
// //      if(argc >= 4)
// //              maxFragSize = atoi(argv[3]);
// //      else
//         if (maxFragSize == -1)
//             maxFragSize = maxEdgeCount;
// //      #endif
// 
//         dfsCode = (edgeTupelPointer*)al.malloc(maxEdgeCount*sizeof(edgeTupelPointer));            /* Ein h?ufiger Subgraph kann h?chstens so */
//         edgeMatchList = (edgeListElementPointer*)al.malloc(maxEdgeCount*sizeof(edgeListElement)); /* gro? sein, wie der gr??te Graph in der DB */
// 
//         if (maxNodeCount<3)
//         {
//             maxNodeCount = 3;    /* sonst sind irgendwelche Arrays nicht definiert !!! */
//         }
//         if (edgeLabelCount == 0)
//         {
//             printf("No edges in DB!!!!!!!\n");
//             throw g_span_error();
//         }
//         if (nodeLabelCount == 0)
//         {
//             printf("No nodes in DB!!!!!!!\n");
//             throw g_span_error();
//         }
// 
//         int j,k;
// 
//         nodeID2RightestPathPosition = (int*)al.malloc(maxNodeCount*sizeof(int));           /* max. L?nge eines rechtesten Pfades <= max. Pfadl?nge in */
//         rightestPathPosition2edgeTupelNr = (int*)al.malloc((maxNodeCount)*sizeof(int));    /* den Graphen der DB <= maxNodeCount */
// 
//         fw2ExtensionCountArray = (int*)al.malloc(maxNodeCount*sizeof(int));       /* fw2Extensions k?nnen nur von den Startknoten der Kanten auf dem */
//         remainingFw2ExtensionsArray = (int*)al.malloc(maxNodeCount*sizeof(int));  /* rechtesten Pfad ausgehen, daher Absch?tzung der Gr??e wie oben */
// 
//         bwTable = (edgeTupelPointer**)al.malloc((maxNodeCount-2)*sizeof(edgeTupelPointer*));    /* Zielknoten einer bwEdge kann nur auf dem */
//         for (i=0;i<maxNodeCount-2;i++)                                                         /* rechtesten Pfad liegen und nicht direkter */
//         {                                                                                      /* Vorg?nger des Startknotens der bwEdge sein */
//             bwTable[i] = (edgeTupelPointer*)al.malloc(edgeLabelCount*sizeof(edgeTupelPointer));
//         }
// 
//         fw1Table = (edgeTupelPointer**)al.malloc(nodeLabelCount*sizeof(edgeTupelPointer*));
//         for (i=0;i<nodeLabelCount;i++)
//         {
//             fw1Table[i] = (edgeTupelPointer*)al.gc_malloc(edgeLabelCount*sizeof(edgeTupelPointer));
//         }
// 
//         fw2Table = (edgeTupelPointer***)al.malloc((maxNodeCount-1)*sizeof(edgeTupelPointer**));
//         for (i=0;i<maxNodeCount-1;i++)
//         {
//             fw2Table[i] = (edgeTupelPointer**)al.malloc(nodeLabelCount*sizeof(edgeTupelPointer*));
//             for (j=0;j<nodeLabelCount;j++)
//             {
//                 fw2Table[i][j] = (edgeTupelPointer*)al.gc_malloc(edgeLabelCount*sizeof(edgeTupelPointer));
//             }
//         }
// 
//         fw2CandidateTable = (boolean***)al.gc_malloc((maxNodeCount-1)*sizeof(boolean**));
//         for (i=0;i<maxNodeCount-1;i++)
//         {
//             fw2CandidateTable[i] = (boolean**)al.gc_malloc(nodeLabelCount*sizeof(boolean*));
//             for (j=0;j<nodeLabelCount;j++)
//             {
//                 fw2CandidateTable[i][j] = (boolean*)al.gc_malloc(edgeLabelCount*sizeof(boolean));
//             }
//         }
// 
//         for (i=0;i<maxNodeCount-2;i++)                                     /* Alle Eintr?ge werden mit NULL initialisiert, F?llen des */
//         {                                                                  /* Arrays erfolgt beim Durchlauf durch DB.  */
//             for (j=0;j<edgeLabelCount;j++)
//             {
//                 bwTable[i][j] = NULL;
//             }
//         }
//         for (i=0;i<nodeLabelCount;i++)              /* Alle Eintr?ge werden mit NULL initialisiert, F?llen des Arrays */
//         {                                           /* erfolgt beim Durchlauf durch DB. Arraygr??e kann nie 0 sein */
//             for (j=0;j<edgeLabelCount;j++)
//             {
//                 fw1Table[i][j] = NULL;
//             }
//         }
//         for (i=0;i<maxNodeCount-1;i++)  /* Alle Eintr?ge werden erstmal mit NULL initialisiert, die */
//         {                                                       /* potentiellen Erweiterungen k?nnen aus den rechten Siblings */
//             for (j=0;j<nodeLabelCount;j++)                     /* abgelesen werden, s.u. */
//             {
//                 for (k=0;k<edgeLabelCount;k++)
//                 {
//                     fw2Table[i][j][k] = NULL;
//                 }
//             }
//         }
// 
//         for (i=0;i<maxNodeCount-1;i++)  /* Alle Eintr?ge werden erstmal mit NULL initialisiert, die */
//         {                                                       /* potentiellen Erweiterungen k?nnen aus den rechten Siblings */
//             for (j=0;j<nodeLabelCount;j++)                     /* abgelesen werden, s.u. */
//             {
//                 for (k=0;k<edgeLabelCount;k++)
//                 {
//                     fw2CandidateTable[i][j][k] = FALSE;
//                 }
//             }
//         }
// 
//         edgeTupelPointer tupelIterator = freqOneEdgeGraphs;
//         edgeTupelPointer previousTupel = NULL;
// 
//         //#ifdef AUSGABE
//         //if(createOutput)
//         //  output = fopen(outputfile,"w");
//         //#endif
// 
//         firstNodeOfSubgraph = (graphNodePointer)al.gc_malloc(sizeof(graphNode));
//         lastNodeOfSubgraph = (graphNodePointer)al.gc_malloc(sizeof(graphNode));
//         edgeListElementPointer firstEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));
//         edgeListElementPointer reverseFirstEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));
// 
//         firstNodeOfSubgraph->vertexID = -1;
//         firstNodeOfSubgraph->nextNode = lastNodeOfSubgraph;
//         firstNodeOfSubgraph->firstEdge = firstEdge;
// 
//         lastNodeOfSubgraph->vertexID = -2;
//         lastNodeOfSubgraph->nextNode = NULL;
//         lastNodeOfSubgraph->firstEdge = reverseFirstEdge;
// 
//         firstEdge->edgeStartNode = firstNodeOfSubgraph;
//         firstEdge->edgeTarget = lastNodeOfSubgraph;
//         firstEdge->nextEdgeListElement = NULL;
//         firstEdge->previousEdgeListElement = NULL;
//         firstEdge->reverseEdge = reverseFirstEdge;
// 
//         reverseFirstEdge->edgeStartNode = lastNodeOfSubgraph;
//         reverseFirstEdge->edgeTarget = firstNodeOfSubgraph;;
//         reverseFirstEdge->nextEdgeListElement = NULL;
//         reverseFirstEdge->previousEdgeListElement = NULL;
//         reverseFirstEdge->reverseEdge = firstEdge;
// 
//         boolean result = false;
//         /******* Iterieren ?ber alle freq 1-edge graphs **************************/
// 
//         while (tupelIterator)   /*Iterator ?ber alle frequent 1-edge graphs, die Elemente von S^1 */
//         {
//             dfsCode[0] = tupelIterator;
//             currentSubgraphSize = 1;                 /* Anzahl der Kanten des aktuellen Subgraphen*/
// 
//             firstNodeOfSubgraph->vertexLabel = tupelIterator->firstNodeValue;
//             lastNodeOfSubgraph->vertexLabel = tupelIterator->secondNodeValue;
// 
//             firstEdge->edgeLabel = tupelIterator->edgeValue;
//             reverseFirstEdge->edgeLabel = tupelIterator->edgeValue;
// 
// #ifdef DEBUG
//             printf("new start tupel: (%d, %d, %d, %d, %d)\n", tupelIterator->firstNodeNr,tupelIterator->secondNodeNr,
//                    tupelIterator->firstNodeValue,tupelIterator->edgeValue,tupelIterator->secondNodeValue);
// #endif
// 
// 
//             result = subgraphMining(tupelIterator);
//             if (result == TRUE) {
//                 //printf("1");
//                 break;
//                 //return 1;
//             }
// 
//             /********** Entfernen von k aus der Graphdatenbank ********************/
// 
//             removeEdgeFromDB(newDB , tupelIterator);
// 
// #ifdef SPAVESAVER
//             removeSupergraphList(tupelIterator);
// #endif
// 
//             previousTupel = tupelIterator;
//             tupelIterator = tupelIterator->nextEdgeTupel;   /* setzt Iterator auf n?chsten freq 1-edge Tupel */
// #ifdef SPACESAVER
//             al.free(previousTupel);
// #endif
//         }
// 
//         /********************* FREE ***************************************************/
//         al.free(nodeID2RightestPathPosition);
//         nodeID2RightestPathPosition = NULL;
//         al.free(rightestPathPosition2edgeTupelNr);
//         al.free(fw2ExtensionCountArray);
//         al.free(remainingFw2ExtensionsArray);
// 
//         for (i=0;i<maxNodeCount-2;i++)
//         {
//             al.free(bwTable[i]);
//         }
//         al.free(bwTable);
// 
//         for (i=0;i<nodeLabelCount;i++)
//         {
//             al.free(fw1Table[i]);
//         }
//         al.free(fw1Table);
// 
//         for (i=0;i<maxNodeCount-1;i++)
//         {
//             for (j=0;j<nodeLabelCount;j++)
//             {
//                 al.free(fw2Table[i][j]);
//             }
//             al.free(fw2Table[i]);
//         }
//         al.free(fw2Table);
//         al.free(dfsCode);
//         al.free(edgeMatchList);
//         al.free(newDB);
// 
//         //printStatistic();
// 
//         //#ifdef AUSGABE
//         //if(createOutput)
//         //  fclose(output);
//         //#endif
//         if (result == TRUE) {
//             printf("%d 1\n",run);
// //             printf( "1" );
//             return 1;
//         }
//         else {
//             printf("%d 0\n", run);
// //             printf( "0" );
//             return 0;
//         }
//     }
    
    int maindir(std::vector< const typename sdf_::molecule* > mols, int minsup_, double threshold_, int run, double timeout, bool search_second )
    {
        m_search_second = search_second;
        
        if( !false ) {
            useSymm = TRUE;
            useAscFreqOrder = TRUE;
        }
        
#if 0
        if (argc < 3)
        {
            printUsage();
            throw g_span_error();
        }
        int i = 1;
        while (i < argc-1)
        {
            if (argv[i][0] == '-')
            {
                if (argv[i][1] == 'm')
                {
                    i++;
                    maxFragSize = atoi(argv[i]);
                }
                else if (argv[i][1] == 's')
                {
                    useSymm = TRUE;
                }
                else if (argv[i][1] == 'a')
                {
                    useAscFreqOrder = TRUE;
                }
                else if (argv[i][1] == 'e')
                {
                    useEmbLists = TRUE;
                }
                else if (argv[i][1] == 'h')
                {
                    i++;
                    useEmbLists = TRUE;
                    hybridThreshold = atoi(argv[i]);
                }
                else if (argv[i][1] == 't')
                {
                    findOnlyTrees = TRUE;
                }
                else if (argv[i][1] == 'p')
                {
                    findOnlyPaths = TRUE;
                }
                else
                {
                    //fprintf(stderr,"Unknown option -%s\n\n",*argv[i]);
                    printUsage();
                    throw g_span_error();
                }
            }
            else
            {
                break;
            }

            i++;
        }
#endif
        
                
        minSup = minsup_;
        threshold = threshold_;
        
        
        if( timeout > 0.0 ) {
        
            end_time = gettime() + timeout;
        }
        
        createOutput = true;
//         printf( "run: %d %d %f %f\n", run, minSup, threshold, timeout );
        
//         if (argv[i])
//         {
//             minSup = atoi(argv[i]);
//             if (argv[i+1])
//             {
//                 filename = argv[i+1];
//                 if (argv[i+2])
//                 {
//                     threshold = atof(argv[i+2]);
//                     createOutput = TRUE;
//                     /*if(argv[i+3])
//                     {
//                             outputfile = argv[i+3];
//                             createOutput = TRUE;
//                     }*/
//                 }
//             }
//             else
//             {
//                 printUsage();
//                 throw g_span_error();
//             }
//         }
//         else
//         {
//             printUsage();
//             throw g_span_error();
//         }

//      if(minSup <= 0)
//      {
//              fprintf(stderr, "<minSup> in not a positive integer\n");
//              fprintf(stderr, "Usage: ./a.out <filename> <minSup> (<maxFragSize>)\n");
//              exit(1);
//      }
//         printf( "filename: %s\n", filename );
//         preprocessDB(filename);
        preprocessDB(mols);
        
        //printf("preprocessing finished\n");

//      #ifdef MAXFRAGSIZE
//      if(argc >= 4)
//              maxFragSize = atoi(argv[3]);
//      else
        if (maxFragSize == -1)
            maxFragSize = maxEdgeCount;
//      #endif

        dfsCode = (edgeTupelPointer*)al.malloc(maxEdgeCount*sizeof(edgeTupelPointer));            /* Ein h?ufiger Subgraph kann h?chstens so */
        edgeMatchList = (edgeListElementPointer*)al.malloc(maxEdgeCount*sizeof(edgeListElement)); /* gro? sein, wie der gr??te Graph in der DB */

        if (maxNodeCount<3)
        {
            maxNodeCount = 3;    /* sonst sind irgendwelche Arrays nicht definiert !!! */
        }
        if (edgeLabelCount == 0)
        {
            printf("No edges in DB!!!!!!!\n");
            throw g_span_error();
        }
        if (nodeLabelCount == 0)
        {
            printf("No nodes in DB!!!!!!!\n");
            throw g_span_error();
        }

        int j,k;

        nodeID2RightestPathPosition = (int*)al.malloc(maxNodeCount*sizeof(int));           /* max. L?nge eines rechtesten Pfades <= max. Pfadl?nge in */
        rightestPathPosition2edgeTupelNr = (int*)al.malloc((maxNodeCount)*sizeof(int));    /* den Graphen der DB <= maxNodeCount */

        fw2ExtensionCountArray = (int*)al.malloc(maxNodeCount*sizeof(int));       /* fw2Extensions k?nnen nur von den Startknoten der Kanten auf dem */
        remainingFw2ExtensionsArray = (int*)al.malloc(maxNodeCount*sizeof(int));  /* rechtesten Pfad ausgehen, daher Absch?tzung der Gr??e wie oben */

        bwTable = (edgeTupelPointer**)al.malloc((maxNodeCount-2)*sizeof(edgeTupelPointer*));    /* Zielknoten einer bwEdge kann nur auf dem */
        for (i=0;i<maxNodeCount-2;i++)                                                         /* rechtesten Pfad liegen und nicht direkter */
        {                                                                                      /* Vorg?nger des Startknotens der bwEdge sein */
            bwTable[i] = (edgeTupelPointer*)al.malloc(edgeLabelCount*sizeof(edgeTupelPointer));
        }

        fw1Table = (edgeTupelPointer**)al.malloc(nodeLabelCount*sizeof(edgeTupelPointer*));
        for (i=0;i<nodeLabelCount;i++)
        {
            fw1Table[i] = (edgeTupelPointer*)al.gc_malloc(edgeLabelCount*sizeof(edgeTupelPointer));
        }

        fw2Table = (edgeTupelPointer***)al.malloc((maxNodeCount-1)*sizeof(edgeTupelPointer**));
        for (i=0;i<maxNodeCount-1;i++)
        {
            fw2Table[i] = (edgeTupelPointer**)al.malloc(nodeLabelCount*sizeof(edgeTupelPointer*));
            for (j=0;j<nodeLabelCount;j++)
            {
                fw2Table[i][j] = (edgeTupelPointer*)al.gc_malloc(edgeLabelCount*sizeof(edgeTupelPointer));
            }
        }

        fw2CandidateTable = (boolean***)al.gc_malloc((maxNodeCount-1)*sizeof(boolean**));
        for (i=0;i<maxNodeCount-1;i++)
        {
            fw2CandidateTable[i] = (boolean**)al.gc_malloc(nodeLabelCount*sizeof(boolean*));
            for (j=0;j<nodeLabelCount;j++)
            {
                fw2CandidateTable[i][j] = (boolean*)al.gc_malloc(edgeLabelCount*sizeof(boolean));
            }
        }

        for (i=0;i<maxNodeCount-2;i++)                                     /* Alle Eintr?ge werden mit NULL initialisiert, F?llen des */
        {                                                                  /* Arrays erfolgt beim Durchlauf durch DB.  */
            for (j=0;j<edgeLabelCount;j++)
            {
                bwTable[i][j] = NULL;
            }
        }
        for (i=0;i<nodeLabelCount;i++)              /* Alle Eintr?ge werden mit NULL initialisiert, F?llen des Arrays */
        {                                           /* erfolgt beim Durchlauf durch DB. Arraygr??e kann nie 0 sein */
            for (j=0;j<edgeLabelCount;j++)
            {
                fw1Table[i][j] = NULL;
            }
        }
        for (i=0;i<maxNodeCount-1;i++)  /* Alle Eintr?ge werden erstmal mit NULL initialisiert, die */
        {                                                       /* potentiellen Erweiterungen k?nnen aus den rechten Siblings */
            for (j=0;j<nodeLabelCount;j++)                     /* abgelesen werden, s.u. */
            {
                for (k=0;k<edgeLabelCount;k++)
                {
                    fw2Table[i][j][k] = NULL;
                }
            }
        }

        for (i=0;i<maxNodeCount-1;i++)  /* Alle Eintr?ge werden erstmal mit NULL initialisiert, die */
        {                                                       /* potentiellen Erweiterungen k?nnen aus den rechten Siblings */
            for (j=0;j<nodeLabelCount;j++)                     /* abgelesen werden, s.u. */
            {
                for (k=0;k<edgeLabelCount;k++)
                {
                    fw2CandidateTable[i][j][k] = FALSE;
                }
            }
        }

        edgeTupelPointer tupelIterator = freqOneEdgeGraphs;
        edgeTupelPointer previousTupel = NULL;

        //#ifdef AUSGABE
        //if(createOutput)
        //  output = fopen(outputfile,"w");
        //#endif

        firstNodeOfSubgraph = (graphNodePointer)al.gc_malloc(sizeof(graphNode));
        lastNodeOfSubgraph = (graphNodePointer)al.gc_malloc(sizeof(graphNode));
        edgeListElementPointer firstEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));
        edgeListElementPointer reverseFirstEdge = (edgeListElementPointer)al.gc_malloc(sizeof(edgeListElement));

        firstNodeOfSubgraph->vertexID = -1;
        firstNodeOfSubgraph->nextNode = lastNodeOfSubgraph;
        firstNodeOfSubgraph->firstEdge = firstEdge;

        lastNodeOfSubgraph->vertexID = -2;
        lastNodeOfSubgraph->nextNode = NULL;
        lastNodeOfSubgraph->firstEdge = reverseFirstEdge;

        firstEdge->edgeStartNode = firstNodeOfSubgraph;
        firstEdge->edgeTarget = lastNodeOfSubgraph;
        firstEdge->nextEdgeListElement = NULL;
        firstEdge->previousEdgeListElement = NULL;
        firstEdge->reverseEdge = reverseFirstEdge;

        reverseFirstEdge->edgeStartNode = lastNodeOfSubgraph;
        reverseFirstEdge->edgeTarget = firstNodeOfSubgraph;;
        reverseFirstEdge->nextEdgeListElement = NULL;
        reverseFirstEdge->previousEdgeListElement = NULL;
        reverseFirstEdge->reverseEdge = firstEdge;

        boolean result = false;
        /******* Iterieren ?ber alle freq 1-edge graphs **************************/

        while (tupelIterator)   /*Iterator ?ber alle frequent 1-edge graphs, die Elemente von S^1 */
        {
            dfsCode[0] = tupelIterator;
            currentSubgraphSize = 1;                 /* Anzahl der Kanten des aktuellen Subgraphen*/

            firstNodeOfSubgraph->vertexLabel = tupelIterator->firstNodeValue;
            lastNodeOfSubgraph->vertexLabel = tupelIterator->secondNodeValue;

            firstEdge->edgeLabel = tupelIterator->edgeValue;
            reverseFirstEdge->edgeLabel = tupelIterator->edgeValue;

#ifdef DEBUG
            printf("new start tupel: (%d, %d, %d, %d, %d)\n", tupelIterator->firstNodeNr,tupelIterator->secondNodeNr,
                   tupelIterator->firstNodeValue,tupelIterator->edgeValue,tupelIterator->secondNodeValue);
#endif


            result = subgraphMining(tupelIterator);
            if (result == TRUE) {
                //printf("1");
                break;
                //return 1;
            }

            /********** Entfernen von k aus der Graphdatenbank ********************/

            removeEdgeFromDB(newDB , tupelIterator);

#ifdef SPAVESAVER
            removeSupergraphList(tupelIterator);
#endif

            previousTupel = tupelIterator;
            tupelIterator = tupelIterator->nextEdgeTupel;   /* setzt Iterator auf n?chsten freq 1-edge Tupel */
#ifdef SPACESAVER
            al.free(previousTupel);
#endif
        }

        /********************* FREE ***************************************************/
        al.free(nodeID2RightestPathPosition);
        nodeID2RightestPathPosition = NULL;
        al.free(rightestPathPosition2edgeTupelNr);
        al.free(fw2ExtensionCountArray);
        al.free(remainingFw2ExtensionsArray);

        for (i=0;i<maxNodeCount-2;i++)
        {
            al.free(bwTable[i]);
        }
        al.free(bwTable);

        for (i=0;i<nodeLabelCount;i++)
        {
            al.free(fw1Table[i]);
        }
        al.free(fw1Table);

        for (i=0;i<maxNodeCount-1;i++)
        {
            for (j=0;j<nodeLabelCount;j++)
            {
                al.free(fw2Table[i][j]);
            }
            al.free(fw2Table[i]);
        }
        al.free(fw2Table);
        al.free(dfsCode);
        al.free(edgeMatchList);
        al.free(newDB);

        //printStatistic();

        //#ifdef AUSGABE
        //if(createOutput)
        //  fclose(output);
        //#endif
        if (nrFrags==1){
//                 printf("%d\n",1);
                return 1;
        }
        else if(nrFrags>1){
//                 printf("%d\n",2);
                return 2;       
        } else{
//                 printf("%d\n",0);
                return 0;
        }

    }

};
// int g_span::edgeLabelFrequency[MAX_EDGE_TYPES];   /* Index ist EdgeLabel, Wert die Häufigkeit des edgeLabels */
// int g_span::nodeLabelFrequency[MAX_NODE_TYPES];   /* Index ist NodeLabel, Wert die Häufigkeit des nodeLabels */



// #include <boost/thread.hpp>

#endif



// #include <boost/algorithm/string.hpp>

int main( int argc, char *argv[] ) {
//     if(atexit(callback)){
//         fprintf(stderr, "Failed to register the call back\n");
//         return 1;
//     }


//     
//     runner r(argc, argv);
// 
//     boost::thread_group tg;
//     tg.create_thread( r );
    
    
    
//     

//     g_span gs2;
//     gs2.mainxxx(argc, argv);

    
    //gs.mainxxx(argc, argv );
    
    std::istream &is = std::cin;

    typedef ivy_mike::sdf_eco sdf_impl;

    while( !is.eof() ) {
        const size_t line_len = 100;
        char line[line_len];

        is.getline(line, line_len);
//         printf( "line: %s\n", line );
        if( line[0] == 'e' || line[0] == 'v' || line[0] == 't' || line[0] == 'x') {
            continue; // skip remaining input (maybe after error)
        } 
        if( line[0] != 'r' ) {
            printf( "exit on end\n" );
            break;
            
        }
        
        
        //assert( line[0] == 'r' );
        
        std::string sline(line);
        std::istringstream iss(sline);

        char id;
        iss >> id;
        
        int run;
        iss >> run;
        
        
        
        //printf( "run: %d\n", run );
        int minSup;
        iss >> minSup;
        double threshold;
        iss >> threshold;
        
        double timeout = 0.0;
        iss >> timeout;

	int search_second;
	iss >> search_second;
//         printf( "timeout: %f\n", timeout );
        
//        std::cout << "eof: " << std::cin.eof() << "\n";
        try {
            sdf_impl si(std::cin, false);
            const std::vector<sdf_impl::molecule> &mols = si.get_molecules();

            std::vector<const sdf_impl::molecule *> mps;
            for( size_t i = 0; i != mols.size(); ++i ) {
                 mps.push_back( &mols[i] );
            }

            g_span<sdf_impl> gs;
//            gs.mainis(std::cin, minSup, threshold, run, timeout);
            int ret = gs.maindir( mps, minSup, threshold, run, timeout, search_second == 1 );


	    printf( "%d %d\n", run, ret );
            if( ret == 1 ) {
                std::vector<sdf_impl::molecule> &bbs = gs.get_backbones();
                assert( bbs.size() == 1 );
                sdf_impl::write_mdl( bbs.front(), std::cout );
	    }

        } catch( g_span_error x ) {
            
          //  printf( "gspan error caught: %s\n", x.what() );
            printf( "%d 128\n", run );
        } catch( timeout_exception x ) {
            //printf( "timeout. abort\n" );
            printf( "%d 129\n", run );
        }
        
        
    }
    printf( "exit on notrun\n" );
    //tg.join_all();
    
//     tg.join_all();
    
}
